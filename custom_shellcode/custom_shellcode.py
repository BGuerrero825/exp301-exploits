import ctypes, struct
from keystone import *


CODE = (
# 1. ##### Starting point, create stack space ######
        "start:                  " #
        "   int3                ;" # DEBUGGING PURPOSES: Interrupt exec to attach debugger
        "   mov ebp, esp        ;" # move up the base pointer to imitate a function call
        "   add esp, 0xfffffdf0 ;" # move up the stack pointer making a buffer to hold structure pushes (adds a negative number to avoid null bytes)

# 2. ##### Find the base address of KERNEL32 through the PEB ######

        "find_kernel32:          " #
        "   xor ecx, ecx        ;" # zero out ecx
        "   mov esi,fs:[ecx+30h];" # get the PEB address (30h into the TEB)
        "   mov esi, [esi+0Ch]  ;" # get the Ldr address from PEB
        "   mov esi, [esi+1Ch]  ;" # get the InItOrder first link address from Ldr

        "next_module:            " #
        "   mov ebx, [esi+8h]   ;" # get the module base address of the linked entry
        "   mov edi, [esi+20h]  ;" # get the module name
        "   mov esi, [esi]      ;" # get the flink entry
        "   cmp [edi+12*2], cx  ;" # check for null byte at word 13 (byte 26) of module name (KERNEL32.DLL)
        "   jne next_module     ;" # move on to next module if no match

# 3. ##### Dynamically calculate an absolute address for find_function ######

        "find_function_shorten:  " # 
        "   jmp find_function_shorten_bnc;" # jump to a location after find_function_ret

        "find_function_ret:      " #
        "   pop esi             ;" # get find_function address
        "   mov [ebp+0x04], esi ;" # move find_function address on the stack for later calls
        "   jmp resolve_symbols_kernel32;" # jump to entry symbol (function) finding logic

        "find_function_shorten_bnc:" # 
        "   call find_function_ret;" # call upwards to save this address + 1 (find_function) on the stack

# 5. ##### Traverse the PE to get KERNEL32 function names ###### 

        "find_function:          " #
        "   pushad              ;" # push registers to the stack for later
        "   mov eax, [ebx+0x3c] ;" # get the PE header address from the DOS Header
        "   mov edi, [ebx+eax+0x78] ;" # get the Export Directory Table RVA from the PE header
        "   add edi, ebx        ;" # get the VMA of the EDT
        "   mov ecx, [edi+0x18] ;" # get the NumberOfNames (for use as a counter)
        "   mov eax, [edi+0x20] ;" # get the AddressOfNames RVA
        "   add eax, ebx        ;" # get the VMA of AddressOfNames
        "   mov [ebp-4], eax    ;" # save the AddressOfNames VMA on the stack

        "find_function_loop:     "
        "   jecxz find_function_finished ;" # jump to cleanup if ecx (counter) is 0
        "   dec ecx             ;" # decrement the NumberOfNames counter
        "   mov eax, [ebp-4]    ;" # restore the AddressOfNames VMA
        "   mov esi, [eax+ecx*4];" # get the nth (counter) function name RVA (VMA+counter*DWORD ptr)
        "   add esi, ebx        ;" # get the VMA of the function name 

# 6. ##### Generate a hash to compare to pre-gen hash ######

        "hash_prep:              " #
        "   xor eax, eax        ;" # zero out eax
        "   cdq                 ;" # set edx equal to eax (zero out)
        "   cld                 ;" # clear direction flag (when DF=0 string ops increment ESI/EDI)
        
        "hash_loop:              " # 
        "   lodsb               ;" # load next byte from string buffer (esi) into al
        "   test al, al         ;" # bitwise AND, sets ZF to 0 if al is 0 (null terminator)
        "   jz hash_finished    ;" # jumps out of loop if at end of string
        "   ror edx, 0x0d       ;" # rotate edx (hash accumulator) 13 bytes right
        "   add edx, eax        ;" # add next string byte into the accumulation
        "   jmp hash_loop       ;" # repeat if not the end

        "hash_finished:          " #
    
# 7. ##### Compare hashes and calculate function address on match ######    

        "find_function_compare:  " #
        "   cmp edx, [esp+0x24] ;" # compare the pre-gen and newly generated hash
        "   jnz find_function_loop  ;" # jump back to find function logic if not a match
        "   mov edx, [edi+0x24] ;" # get AddressOfNameOrdinals RVA
        "   add edx, ebx        ;" # get AddressOfNameOrdinals VMA
        "   mov cx, [edx+2*ecx] ;" # overwrite names index with value from ...NameOrdinals[index]  
        "   mov edx, [edi+0x1c] ;" # get AddressOfFunctions RVA
        "   add edx, ebx        ;" # get AddressOfFunctions VMA
        "   mov eax, [edx+4*ecx];" # overwrite ordinal index with RVA of desired function
        "   add eax, ebx        ;" # get desired function VMA
        "   mov [esp+0x1c], eax ;" # overwrite pushad register value of eax with the function VMA

        "find_function_finished: "
        "   popad               ;" # restore original register values
        "   ret                 ;" # 

# 4. ##### Upward call to find_function ######

        "resolve_symbols_kernel32: " #
        "   push 0x78b5b983     ;" # push pre-generated hash for TerminateProcess to stack
        "   call dword ptr [ebp+0x04];" # call find_function using its absolute address on stack
        "   mov [ebp+0x10], eax ;" # move find_function return value to stack 
        
# 8. ##### Set up and system call to TerminateProcess ######

        "exec_shellcode:         " #
        "   xor ecx, ecx        ;" # zero out ecx
        "   push ecx            ;" # push uExitCode arg as 0 for syscall
        "   push 0xffffffff     ;" # push hProcess arg as -1 (psuedo-handle)
        "   call dword ptr [ebp+0x10];" # call TerminateProcess using its address on the stack

        )


### generate shellcode ###
# init engine in x86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)
sh = b""
for e in encoding:
    sh += struct.pack("B", e) # add each byte object from an unsigned char (B)
shellcode = bytearray(sh)


### makes the shellcode executable ###
# allocate mem page with PAGE_EXEC_READWRITE perms, returns a pointer
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3004),
                                          ctypes.c_int(0x40))
# tbh not sure here, but makes a ctype compatible buffer space from the shellcode
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
# move the buffer into the memory page
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


### executes the shellcode ###
print("Shellcode located at address %s" % hex(ptr))
input("...PRESS ENTER TO EXECUTE SHELLCODE...")
# creates the thread environment for the shellcode to run
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
