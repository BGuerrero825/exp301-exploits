import ctypes, struct
from keystone import *


### assembly code ###
CODE = (
        "start:                  " #
        "   int3                ;" # DEBUGGING PURPOSES: Interrupt exec to attach debugger
        "   mov ebp, esp        ;" # move up the base pointer to imitate a function call
        "   sub esp, 0x200      ;" # move up the stack pointer making a buffer to hold structure pushes
        "   call find_kernel32  ;" #
        "   push 0x78b5b983     ;" # push the TerminateProcess hash
        "   call find_function  ;" #
        "   xor ecx, ecx        ;" # zero out ecx
        "   push ecx            ;" # push uExitCode arg as 0 for syscall
        "   push 0xffffffff     ;" # push hProcess arg as -1 (psuedo-handle)
        "   call eax            ;" # call TerminateProcess using its address

        "find_kernel32:          " #
        "   xor ecx, ecx        ;" # zero out ecx
        "   mov esi,fs:[ecx+30h];" # get the PEB address (30h into the TEB)
        "   mov esi,[esi+0Ch]   ;" # get the Ldr address from PEB
        "   mov esi,[esi+1Ch]   ;" # get the InItOrder first link address from Ldr

        "next_module:            " #
        "   mov ebx, [esi+8h]   ;" # get the module base address of the linked entry
        "   mov edi, [esi+20h]  ;" # get the module name
        "   mov esi, [esi]      ;" # get the flink entry
        "   cmp [edi+12*2], cx  ;" # check for null byte at word 13 (byte 26) of module name (KERNEL32.DLL)
        "   jne next_module     ;" # move on to next module if no match
        "   ret                 ;" #

        "find_function:          "
        "   pushad              ;" # push registers to the stack for later
        "   mov eax, [ebx+0x3c] ;" # get the PE header address from the DOS Header
        "   mov edi, [ebx+eax+0x78] ;" # get the Export Directory Table RVA from the PE header
        "   add edi, ebx        ;" # get the VMA of the EDT
        "   mov ecx, [edi+0x18] ;" # get the NumberOfNames (for use as a counter)
        "   mov eax, [edi+0x20] ;" # get the AddressOfNames RVA
        "   add eax, ebx        ;" # get the VMA of AddressOfNames
        "   mov [ebp-4], eax    ;" # save the AddressOfNames VMA on the stack

        "find_function_loop:     "
        "   jecxz find_function_finished ;" # jump to cleanup if ecx (counter) is 0
        "   dec ecx             ;" # decrement the NumberOfNames counter
        "   mov eax, [ebp-4]    ;" # restore the AddressOfNames VMA
        "   mov esi, [eax+ecx*4];" # get the nth (counter) function name RVA (VMA+counter*DWORD ptr)
        "   add esi, ebx        ;" # get the VMA of the function name 

        "hash_prep:              " #
        "   xor eax, eax        ;" # zero out eax
        "   cdq                 ;" # set edx equal to eax (zero out)
        "   cld                 ;" # clear direction flag (when DF=0 string ops increment ESI/EDI)
        
        "hash_loop:             ;" # 
        "   lodsb               ;" # load next byte from string buffer (esi) into al
        "   test al, al         ;" # bitwise AND, sets ZF to 0 if al is 0 (null terminator)
        "   jz hash_finished    ;" # jumps out of loop if at end of string
        "   ror edx, 0x0d       ;" # rotate edx (hash accumulator) 13 bytes right
        "   add edx, eax        ;" # add next string byte into the accumulation
        "   jmp hash_loop       ;" # repeat if not the end

        "hash_finished:          " #
    
        "find_function_compare:  " #
        "   cmp edx, [esp+0x24] ;" # compare the pre-gen and newly generated hash
        "   jnz find_function_loop  ;" # jump back to find function logic if not a match
        "   mov edx, [edi+0x24] ;" # get AddressOfNameOrdinals RVA
        "   add edx, ebx        ;" # get AddressOfNameOrdinals VMA
        "   mov cx, [edx+2*ecx] ;" # overwrite names index with value from ...NameOrdinals[index]  
        "   mov edx, [edi+0x1c] ;" # get AddressOfFunctions RVA
        "   add edx, ebx        ;" # get AddressOfFunctions VMA
        "   mov eax, [edx+4*ecx];" # overwrite ordinal index with RVA of desired function
        "   add eax, ebx        ;" # get desired function VMA
        "   mov [esp+0x1c], eax ;" # overwrite pushad register value of eax with the function VMA

        "find_function_finished: "
        "   popad               ;" # restore original register values
        "   ret                 ;" # 


        )


### generate shellcode ###
# init engine in x86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)
sh = b""
for e in encoding:
    sh += struct.pack("B", e) # add each byte object from an unsigned char (B)
shellcode = bytearray(sh)


### makes the shellcode executable ###
# allocate mem page with PAGE_EXEC_READWRITE perms, returns a pointer
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3004),
                                          ctypes.c_int(0x40))
# tbh not sure here, but makes a ctype compatible buffer space from the shellcode
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
# move the buffer into the memory page
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


### executes the shellcode ###
print("Shellcode located at address %s" % hex(ptr))
input("...PRESS ENTER TO EXECUTE SHELLCODE...")
# creates the thread environment for the shellcode to run
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
